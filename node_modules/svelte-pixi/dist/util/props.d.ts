import * as PIXI from 'pixi.js';
import { type Writable } from 'svelte/store';
import { type PointLike } from './data-types';
/**
 * Returns apply prop functions that are bound to the instance
 */
export declare function createApplyProps<Instance, Props extends Partial<Record<keyof Instance, any>> = {
    [Key in keyof Instance]?: Instance[Key];
}>(instance: Instance, apply?: {
    [PropKey in keyof Props]?: Apply<Instance, Props[PropKey]>;
}): {
    applyProps: (props: Partial<Props>) => void;
    applyProp: <Prop extends keyof Props, Value>(prop: Prop | null, value: Value) => void;
};
/**
 * Applies all props to the instance if its value is not undefined and
 * is not equal to the instance's value of the prop.
 *
 * Usage:
 *
 * ```js
 * applyProps(instance, { x, y })
 * // or
 * applyProps(instance, { x }, {
 *  x: value => instance.x = value,
 *  y: value => instance.y = value,
 * })
 * ```
 */
export declare function applyProps<Instance, Props extends Partial<Record<keyof Instance, any>>>(instance: Instance, props: Props, apply?: {
    [Prop in keyof Props]?: Apply<Instance, Props[Prop]>;
}): void;
/**
 * Applies a single prop to the instance if the value is not undefined and
 * is not equal to the instance's value of the prop.
 *
 * Usage:
 *
 * ```js
 * applyProp(instance, 'x', x)
 * // or
 * applyProp(instance, 'x', x, () => instance.x = x)
 * ```
 *
 * The 2nd parameter is an object to decrease tediousness of describing
 * the prop name & value, as they are often the same. It will only apply
 * the first key of the object. Use applyProps() if you need to apply more than 1
 * at the same time.
 */
export declare function applyProp<Instance, Prop extends keyof Instance, Value>(instance: Instance, prop: Prop | null, value: Value, apply?: Apply<Instance, Value>): void;
export declare function track<T>(getter: () => T, initial?: T): Writable<T>;
export type ExtractProps<T> = Partial<SwapPoints<Pick<T, NotFunctions<T> & PublicProperties<T>>>>;
export type ExtractPropKeys<T> = Pick<T, NotFunctions<T> & PublicProperties<T>>;
export type Apply<Instance, Value> = (value: Value, instance: Instance) => any;
type FilterNotStartingWith<Set, Needle extends string> = Set extends `${Needle}${infer _X}` ? never : Set;
type PublicProperties<T> = FilterNotStartingWith<keyof T, '_'>;
/**
 * Converts Point or ObservablePoint types to PointLike
 */
type SwapPoints<T> = T extends {} ? {
    [K in keyof T]: T[K] extends PIXI.Point | PIXI.ObservablePoint ? PointLike : T[K];
} : T;
type NotFunctions<T> = {
    [K in keyof T]-?: T[K] extends Function ? never : K;
}[keyof T];
export {};
