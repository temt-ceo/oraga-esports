import { getRenderer } from '../Renderer.svelte';
import { getTicker, onTick } from '../Ticker.svelte';
import * as PIXI from 'pixi.js';
import { onMount, tick } from 'svelte';
import { writable } from 'svelte/store';
import { parsePoint } from './data-types';
/**
 * Returns apply prop functions that are bound to the instance
 */
export function createApplyProps(instance, apply) {
    const defaultApply = apply;
    return {
        applyProps: (props) => applyProps(instance, props, { ...defaultApply, ...apply }),
        applyProp: (prop, value) => applyProp(instance, prop, value, prop !== null ? defaultApply?.[prop] : undefined),
    };
}
/**
 * Applies all props to the instance if its value is not undefined and
 * is not equal to the instance's value of the prop.
 *
 * Usage:
 *
 * ```js
 * applyProps(instance, { x, y })
 * // or
 * applyProps(instance, { x }, {
 *  x: value => instance.x = value,
 *  y: value => instance.y = value,
 * })
 * ```
 */
export function applyProps(instance, props, apply) {
    if (instance) {
        for (const [prop, value] of Object.entries(props)) {
            applyProp(instance, prop, value, apply?.[prop]);
        }
    }
}
/**
 * Applies a single prop to the instance if the value is not undefined and
 * is not equal to the instance's value of the prop.
 *
 * Usage:
 *
 * ```js
 * applyProp(instance, 'x', x)
 * // or
 * applyProp(instance, 'x', x, () => instance.x = x)
 * ```
 *
 * The 2nd parameter is an object to decrease tediousness of describing
 * the prop name & value, as they are often the same. It will only apply
 * the first key of the object. Use applyProps() if you need to apply more than 1
 * at the same time.
 */
export function applyProp(instance, prop, value, apply) {
    if (instance) {
        if (prop === null) {
            apply?.(value, instance);
        }
        else {
            const instanceValue = instance[prop];
            if (instanceValue !== value && typeof value !== 'undefined') {
                if (apply) {
                    apply(value, instance);
                }
                else {
                    if (instance[prop] instanceof PIXI.Point ||
                        instance[prop] instanceof PIXI.ObservablePoint) {
                        instance[prop] = parsePoint(value);
                    }
                    else {
                        instance[prop] = value;
                    }
                }
            }
        }
    }
}
export function track(getter, initial) {
    const { renderer } = getRenderer();
    const { ticker } = getTicker();
    const value = writable(initial);
    function update() {
        // svelte tick() first incase stores were updated
        // and passed down as a prop between pixi ticks
        tick().then(() => {
            value.set(getter());
        });
    }
    onMount(() => {
        if (!ticker) {
            renderer.on('postrender', update);
            return () => {
                renderer.off('postrender', update);
            };
        }
    });
    if (ticker) {
        onTick(() => {
            update();
        }, -Infinity);
    }
    return value;
}
