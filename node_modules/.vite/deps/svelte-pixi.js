import {
  AnimatedSprite,
  Application,
  Assets,
  BLEND_MODES,
  BitmapText,
  Container,
  Graphics,
  HTMLText,
  MSAA_QUALITY,
  Mesh,
  NineSlicePlane,
  ObservablePoint,
  ParticleContainer,
  Point,
  RopeGeometry,
  SimplePlane,
  SimpleRope,
  Sprite,
  Text,
  Ticker,
  TilingSprite,
  UPDATE_PRIORITY,
  autoDetectRenderer,
  lib_exports2 as lib_exports,
  settings
} from "./chunk-6BLFHLK5.js";
import "./chunk-DYWWDCTU.js";
import {
  writable
} from "./chunk-26PYRFXW.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  assign,
  bubble,
  check_outros,
  compute_rest_props,
  compute_slots,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  mount_component,
  noop,
  onMount,
  safe_not_equal,
  setContext,
  space,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-XV4MNA7B.js";
import "./chunk-672HPU4M.js";
import "./chunk-DC5AMYBS.js";

// node_modules/svelte-pixi/dist/util/helpers.js
function omitUndefined(object) {
  return Object.keys(object).reduce((acc, key) => {
    if (typeof object[key] === "undefined") {
      return acc;
    }
    return {
      ...acc,
      [key]: object[key]
    };
  }, {});
}

// node_modules/svelte-pixi/dist/Renderer.svelte
var { Error: Error_1 } = globals;
var file = "node_modules/svelte-pixi/dist/Renderer.svelte";
var get_view_slot_changes = (dirty) => ({});
var get_view_slot_context = (ctx) => ({});
function create_else_block(ctx) {
  let div;
  let view_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      add_location(div, file, 145, 2, 3947);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(view_action = /*view*/
        ctx[0].call(null, div));
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(145:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let view_action;
  let current;
  let mounted;
  let dispose;
  const view_slot_template = (
    /*#slots*/
    ctx[19].view
  );
  const view_slot = create_slot(
    view_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_view_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (view_slot) view_slot.c();
      add_location(div, file, 141, 2, 3888);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (view_slot) {
        view_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(view_action = /*view*/
        ctx[0].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (view_slot) {
        if (view_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            view_slot,
            view_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              view_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_view_slot_changes
            ),
            get_view_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(view_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (view_slot) view_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(141:0) {#if $$slots.view}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[1].view
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      if_block.c();
      t = space();
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if_blocks[current_block_type_index].d(detaching);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getRenderer() {
  return getContext("pixi/renderer");
}
function instance_1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Renderer", slots, ["view", "default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { width = 800 } = $$props;
  let { height = 600 } = $$props;
  let { useContextAlpha = void 0 } = $$props;
  let { autoDensity = true } = $$props;
  let { antialias = false } = $$props;
  let { eventMode = void 0 } = $$props;
  let { eventFeatures = void 0 } = $$props;
  let { preserveDrawingBuffer = false } = $$props;
  let { resolution = settings.RESOLUTION } = $$props;
  let { forceCanvas = false } = $$props;
  let { backgroundColor = 0 } = $$props;
  let { backgroundAlpha = 1 } = $$props;
  let { clearBeforeRender = void 0 } = $$props;
  let { powerPreference = void 0 } = $$props;
  let { premultipliedAlpha = void 0 } = $$props;
  let { instance: instance2 = autoDetectRenderer(omitUndefined({
    width,
    height,
    useContextAlpha,
    autoDensity,
    antialias,
    preserveDrawingBuffer,
    premultipliedAlpha,
    resolution,
    forceCanvas,
    backgroundColor,
    backgroundAlpha,
    clearBeforeRender,
    powerPreference,
    eventMode,
    eventFeatures
  })) } = $$props;
  setContext("pixi/renderer", {
    renderer: instance2,
    invalidate: () => {
      dispatch("invalidate");
    }
  });
  function view(node) {
    if (!(instance2.view instanceof HTMLElement)) {
      throw new Error("PIXI.Renderer.view is not an HTMLElement, cannot append to node");
    }
    if (node.childNodes.length) {
      node.childNodes[0].appendChild(instance2.view);
    } else {
      node.appendChild(instance2.view);
    }
  }
  onMount(() => {
    instance2.on("prerender", (ev) => dispatch("prerender", ev));
    instance2.on("postrender", (ev) => dispatch("postrender", ev));
  });
  const writable_props = [
    "width",
    "height",
    "useContextAlpha",
    "autoDensity",
    "antialias",
    "eventMode",
    "eventFeatures",
    "preserveDrawingBuffer",
    "resolution",
    "forceCanvas",
    "backgroundColor",
    "backgroundAlpha",
    "clearBeforeRender",
    "powerPreference",
    "premultipliedAlpha",
    "instance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Renderer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("useContextAlpha" in $$props2) $$invalidate(4, useContextAlpha = $$props2.useContextAlpha);
    if ("autoDensity" in $$props2) $$invalidate(5, autoDensity = $$props2.autoDensity);
    if ("antialias" in $$props2) $$invalidate(6, antialias = $$props2.antialias);
    if ("eventMode" in $$props2) $$invalidate(7, eventMode = $$props2.eventMode);
    if ("eventFeatures" in $$props2) $$invalidate(8, eventFeatures = $$props2.eventFeatures);
    if ("preserveDrawingBuffer" in $$props2) $$invalidate(9, preserveDrawingBuffer = $$props2.preserveDrawingBuffer);
    if ("resolution" in $$props2) $$invalidate(10, resolution = $$props2.resolution);
    if ("forceCanvas" in $$props2) $$invalidate(11, forceCanvas = $$props2.forceCanvas);
    if ("backgroundColor" in $$props2) $$invalidate(12, backgroundColor = $$props2.backgroundColor);
    if ("backgroundAlpha" in $$props2) $$invalidate(13, backgroundAlpha = $$props2.backgroundAlpha);
    if ("clearBeforeRender" in $$props2) $$invalidate(14, clearBeforeRender = $$props2.clearBeforeRender);
    if ("powerPreference" in $$props2) $$invalidate(15, powerPreference = $$props2.powerPreference);
    if ("premultipliedAlpha" in $$props2) $$invalidate(16, premultipliedAlpha = $$props2.premultipliedAlpha);
    if ("instance" in $$props2) $$invalidate(17, instance2 = $$props2.instance);
    if ("$$scope" in $$props2) $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRenderer,
    PIXI: lib_exports,
    createEventDispatcher,
    getContext,
    onMount,
    setContext,
    omitUndefined,
    dispatch,
    width,
    height,
    useContextAlpha,
    autoDensity,
    antialias,
    eventMode,
    eventFeatures,
    preserveDrawingBuffer,
    resolution,
    forceCanvas,
    backgroundColor,
    backgroundAlpha,
    clearBeforeRender,
    powerPreference,
    premultipliedAlpha,
    instance: instance2,
    view
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2) $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(3, height = $$props2.height);
    if ("useContextAlpha" in $$props2) $$invalidate(4, useContextAlpha = $$props2.useContextAlpha);
    if ("autoDensity" in $$props2) $$invalidate(5, autoDensity = $$props2.autoDensity);
    if ("antialias" in $$props2) $$invalidate(6, antialias = $$props2.antialias);
    if ("eventMode" in $$props2) $$invalidate(7, eventMode = $$props2.eventMode);
    if ("eventFeatures" in $$props2) $$invalidate(8, eventFeatures = $$props2.eventFeatures);
    if ("preserveDrawingBuffer" in $$props2) $$invalidate(9, preserveDrawingBuffer = $$props2.preserveDrawingBuffer);
    if ("resolution" in $$props2) $$invalidate(10, resolution = $$props2.resolution);
    if ("forceCanvas" in $$props2) $$invalidate(11, forceCanvas = $$props2.forceCanvas);
    if ("backgroundColor" in $$props2) $$invalidate(12, backgroundColor = $$props2.backgroundColor);
    if ("backgroundAlpha" in $$props2) $$invalidate(13, backgroundAlpha = $$props2.backgroundAlpha);
    if ("clearBeforeRender" in $$props2) $$invalidate(14, clearBeforeRender = $$props2.clearBeforeRender);
    if ("powerPreference" in $$props2) $$invalidate(15, powerPreference = $$props2.powerPreference);
    if ("premultipliedAlpha" in $$props2) $$invalidate(16, premultipliedAlpha = $$props2.premultipliedAlpha);
    if ("instance" in $$props2) $$invalidate(17, instance2 = $$props2.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    view,
    $$slots,
    width,
    height,
    useContextAlpha,
    autoDensity,
    antialias,
    eventMode,
    eventFeatures,
    preserveDrawingBuffer,
    resolution,
    forceCanvas,
    backgroundColor,
    backgroundAlpha,
    clearBeforeRender,
    powerPreference,
    premultipliedAlpha,
    instance2,
    $$scope,
    slots
  ];
}
var Renderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      width: 2,
      height: 3,
      useContextAlpha: 4,
      autoDensity: 5,
      antialias: 6,
      eventMode: 7,
      eventFeatures: 8,
      preserveDrawingBuffer: 9,
      resolution: 10,
      forceCanvas: 11,
      backgroundColor: 12,
      backgroundAlpha: 13,
      clearBeforeRender: 14,
      powerPreference: 15,
      premultipliedAlpha: 16,
      instance: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Renderer",
      options,
      id: create_fragment.name
    });
  }
  get width() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useContextAlpha() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useContextAlpha(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoDensity() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoDensity(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get antialias() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set antialias(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventMode() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventMode(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventFeatures() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventFeatures(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preserveDrawingBuffer() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preserveDrawingBuffer(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resolution() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resolution(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceCanvas() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceCanvas(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundAlpha() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundAlpha(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearBeforeRender() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearBeforeRender(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get powerPreference() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set powerPreference(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get premultipliedAlpha() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set premultipliedAlpha(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error_1("<Renderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error_1("<Renderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Renderer_default = Renderer;

// node_modules/svelte-pixi/dist/Ticker.svelte
var { Error: Error_12 } = globals;
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error_12("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getTicker() {
  return getContext("pixi/ticker");
}
function onTick(fn, priority) {
  const { ticker } = getTicker();
  onMount(() => {
    if (ticker) {
      ticker.add(fn, null, priority);
      return () => {
        if (ticker && ticker._head) {
          ticker.remove(fn, null);
        }
      };
    } else {
      throw new Error(`onTick requires a parent <Ticker />`);
    }
  });
}
function instance_12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ticker", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { autoStart = true } = $$props;
  let { maxFPS = 0 } = $$props;
  let { minFPS = 10 } = $$props;
  let { speed = 1 } = $$props;
  let { instance: instance2 = new Ticker() } = $$props;
  let { priority = UPDATE_PRIORITY.LOW } = $$props;
  setContext("pixi/ticker", { ticker: instance2 });
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  onMount(() => {
    instance2.add(
      (delta) => {
        dispatch("tick", delta);
      },
      priority
    );
    return () => {
      instance2.destroy();
    };
  });
  const writable_props = ["autoStart", "maxFPS", "minFPS", "speed", "instance", "priority"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Ticker> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("autoStart" in $$props2) $$invalidate(0, autoStart = $$props2.autoStart);
    if ("maxFPS" in $$props2) $$invalidate(1, maxFPS = $$props2.maxFPS);
    if ("minFPS" in $$props2) $$invalidate(2, minFPS = $$props2.minFPS);
    if ("speed" in $$props2) $$invalidate(3, speed = $$props2.speed);
    if ("instance" in $$props2) $$invalidate(4, instance2 = $$props2.instance);
    if ("priority" in $$props2) $$invalidate(5, priority = $$props2.priority);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getTicker,
    onTick,
    PIXI: lib_exports,
    createEventDispatcher,
    getContext,
    onMount,
    setContext,
    createApplyProps,
    dispatch,
    autoStart,
    maxFPS,
    minFPS,
    speed,
    instance: instance2,
    priority,
    applyProp: applyProp2
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoStart" in $$props2) $$invalidate(0, autoStart = $$props2.autoStart);
    if ("maxFPS" in $$props2) $$invalidate(1, maxFPS = $$props2.maxFPS);
    if ("minFPS" in $$props2) $$invalidate(2, minFPS = $$props2.minFPS);
    if ("speed" in $$props2) $$invalidate(3, speed = $$props2.speed);
    if ("instance" in $$props2) $$invalidate(4, instance2 = $$props2.instance);
    if ("priority" in $$props2) $$invalidate(5, priority = $$props2.priority);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoStart*/
    1) {
      $: applyProp2("autoStart", autoStart);
    }
    if ($$self.$$.dirty & /*maxFPS*/
    2) {
      $: applyProp2("maxFPS", maxFPS);
    }
    if ($$self.$$.dirty & /*minFPS*/
    4) {
      $: applyProp2("minFPS", minFPS);
    }
    if ($$self.$$.dirty & /*speed*/
    8) {
      $: applyProp2("speed", speed);
    }
  };
  return [autoStart, maxFPS, minFPS, speed, instance2, priority, $$scope, slots];
}
var Ticker2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      autoStart: 0,
      maxFPS: 1,
      minFPS: 2,
      speed: 3,
      instance: 4,
      priority: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ticker",
      options,
      id: create_fragment2.name
    });
  }
  get autoStart() {
    throw new Error_12("<Ticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoStart(value) {
    throw new Error_12("<Ticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxFPS() {
    throw new Error_12("<Ticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxFPS(value) {
    throw new Error_12("<Ticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minFPS() {
    throw new Error_12("<Ticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minFPS(value) {
    throw new Error_12("<Ticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get speed() {
    throw new Error_12("<Ticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set speed(value) {
    throw new Error_12("<Ticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error_12("<Ticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error_12("<Ticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get priority() {
    throw new Error_12("<Ticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set priority(value) {
    throw new Error_12("<Ticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ticker_default = Ticker2;

// node_modules/svelte-pixi/dist/util/data-types.js
function parsePoint(point) {
  if (Array.isArray(point)) {
    return new Point(point[0], point[1]);
  }
  if (typeof point === "number") {
    return new Point(point, point);
  }
  if (point instanceof Point || point instanceof ObservablePoint) {
    return point;
  }
  return new Point(point.x, point.y);
}

// node_modules/svelte-pixi/dist/util/props.js
function createApplyProps(instance2, apply) {
  const defaultApply = apply;
  return {
    applyProps: (props) => applyProps(instance2, props, { ...defaultApply, ...apply }),
    applyProp: (prop, value) => applyProp(instance2, prop, value, prop !== null ? defaultApply == null ? void 0 : defaultApply[prop] : void 0)
  };
}
function applyProps(instance2, props, apply) {
  if (instance2) {
    for (const [prop, value] of Object.entries(props)) {
      applyProp(instance2, prop, value, apply == null ? void 0 : apply[prop]);
    }
  }
}
function applyProp(instance2, prop, value, apply) {
  if (instance2) {
    if (prop === null) {
      apply == null ? void 0 : apply(value, instance2);
    } else {
      const instanceValue = instance2[prop];
      if (instanceValue !== value && typeof value !== "undefined") {
        if (apply) {
          apply(value, instance2);
        } else {
          if (instance2[prop] instanceof Point || instance2[prop] instanceof ObservablePoint) {
            instance2[prop] = parsePoint(value);
          } else {
            instance2[prop] = value;
          }
        }
      }
    }
  }
}
function track(getter, initial) {
  const { renderer } = getRenderer();
  const { ticker } = getTicker();
  const value = writable(initial);
  function update() {
    tick().then(() => {
      value.set(getter());
    });
  }
  onMount(() => {
    if (!ticker) {
      renderer.on("postrender", update);
      return () => {
        renderer.off("postrender", update);
      };
    }
  });
  if (ticker) {
    onTick(() => {
      update();
    }, -Infinity);
  }
  return value;
}

// node_modules/svelte-pixi/dist/Container.svelte
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[39],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[39]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[39],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getContainer() {
  return getContext("pixi/container");
}
function getStage() {
  return getContext("pixi/stage");
}
function instance_13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { accessible = false } = $$props;
  let { accessibleChildren = true } = $$props;
  let { accessibleHint = void 0 } = $$props;
  let { accessiblePointerEvents = "auto" } = $$props;
  let { accessibleTitle = void 0 } = $$props;
  let { accessibleType = "button" } = $$props;
  let { alpha = void 0 } = $$props;
  let { angle = void 0 } = $$props;
  let { cacheAsBitmap = void 0 } = $$props;
  let { cacheAsBitmapMultisample = MSAA_QUALITY.NONE } = $$props;
  let { cacheAsBitmapResolution = void 0 } = $$props;
  let { cullable = void 0 } = $$props;
  let { cullArea = void 0 } = $$props;
  let { cursor = void 0 } = $$props;
  let { eventMode = void 0 } = $$props;
  let { filterArea = void 0 } = $$props;
  let { filters = void 0 } = $$props;
  let { height = void 0 } = $$props;
  let { hitArea = void 0 } = $$props;
  let { interactive = void 0 } = $$props;
  let { interactiveChildren = void 0 } = $$props;
  let { isMask = void 0 } = $$props;
  let { isSprite = void 0 } = $$props;
  let { mask = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { pivot = void 0 } = $$props;
  let { position = void 0 } = $$props;
  let { renderable = void 0 } = $$props;
  let { rotation = void 0 } = $$props;
  let { scale = void 0 } = $$props;
  let { skew = void 0 } = $$props;
  let { sortableChildren = void 0 } = $$props;
  let { width = void 0 } = $$props;
  let { transform = void 0 } = $$props;
  let { visible = void 0 } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { zIndex = void 0 } = $$props;
  let { instance: instance2 = new Container() } = $$props;
  const { applyProp: applyProp2, applyProps: applyProps2 } = createApplyProps(instance2);
  const { invalidate } = getRenderer();
  const { container: parent } = getContainer() ?? {};
  const dispatch = createEventDispatcher();
  onMount(() => {
    let childIndex = -1;
    let _instance = instance2;
    let _parent = parent;
    try {
      childIndex = _parent.getChildIndex(_instance);
    } catch (e) {
    }
    if (_parent && childIndex === -1) {
      _parent.addChild(_instance);
    }
    dispatch("create", { instance: _instance });
    if ($$slots.default) {
      const { instance: instance3, ...props } = $$props;
      applyProps2(props);
    }
    function handleEvent(ev) {
      dispatch(ev.type, ev);
    }
    function handleGlobalEvent(ev) {
      dispatch(`global${ev.type}`, ev);
    }
    instance2.on("click", handleEvent);
    instance2.on("globalmousemove", handleGlobalEvent);
    instance2.on("globalpointermove", handleGlobalEvent);
    instance2.on("globaltouchmove", handleGlobalEvent);
    instance2.on("mousedown", handleEvent);
    instance2.on("mousemove", handleEvent);
    instance2.on("mouseout", handleEvent);
    instance2.on("mouseover", handleEvent);
    instance2.on("mouseup", handleEvent);
    instance2.on("mouseupoutside", handleEvent);
    instance2.on("mouseupoutside", handleEvent);
    instance2.on("pointercancel", handleEvent);
    instance2.on("pointerdown", handleEvent);
    instance2.on("pointermove", handleEvent);
    instance2.on("pointerout", handleEvent);
    instance2.on("pointerover", handleEvent);
    instance2.on("pointertap", handleEvent);
    instance2.on("pointerup", handleEvent);
    instance2.on("pointerupoutside", handleEvent);
    instance2.on("removedFrom", handleEvent);
    instance2.on("rightclick", handleEvent);
    instance2.on("rightdown", handleEvent);
    instance2.on("rightup", handleEvent);
    instance2.on("rightupoutside", handleEvent);
    instance2.on("tap", handleEvent);
    instance2.on("touchcancel", handleEvent);
    instance2.on("touchend", handleEvent);
    instance2.on("touchendoutside", handleEvent);
    instance2.on("touchmove", handleEvent);
    instance2.on("touchstart", handleEvent);
    instance2.on("added", (ev) => dispatch("added", ev));
    instance2.on("removed", (ev) => dispatch("removed", ev));
    return () => {
      _instance == null ? void 0 : _instance.destroy();
      _parent == null ? void 0 : _parent.removeChild(_instance);
      invalidate();
    };
  });
  afterUpdate(() => {
    invalidate();
  });
  if (!parent) {
    setContext("pixi/stage", { stage: instance2 });
  }
  setContext("pixi/container", { container: instance2 });
  $$self.$$set = ($$new_props) => {
    $$invalidate(46, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("accessible" in $$new_props) $$invalidate(0, accessible = $$new_props.accessible);
    if ("accessibleChildren" in $$new_props) $$invalidate(1, accessibleChildren = $$new_props.accessibleChildren);
    if ("accessibleHint" in $$new_props) $$invalidate(2, accessibleHint = $$new_props.accessibleHint);
    if ("accessiblePointerEvents" in $$new_props) $$invalidate(3, accessiblePointerEvents = $$new_props.accessiblePointerEvents);
    if ("accessibleTitle" in $$new_props) $$invalidate(4, accessibleTitle = $$new_props.accessibleTitle);
    if ("accessibleType" in $$new_props) $$invalidate(5, accessibleType = $$new_props.accessibleType);
    if ("alpha" in $$new_props) $$invalidate(6, alpha = $$new_props.alpha);
    if ("angle" in $$new_props) $$invalidate(7, angle = $$new_props.angle);
    if ("cacheAsBitmap" in $$new_props) $$invalidate(8, cacheAsBitmap = $$new_props.cacheAsBitmap);
    if ("cacheAsBitmapMultisample" in $$new_props) $$invalidate(9, cacheAsBitmapMultisample = $$new_props.cacheAsBitmapMultisample);
    if ("cacheAsBitmapResolution" in $$new_props) $$invalidate(10, cacheAsBitmapResolution = $$new_props.cacheAsBitmapResolution);
    if ("cullable" in $$new_props) $$invalidate(11, cullable = $$new_props.cullable);
    if ("cullArea" in $$new_props) $$invalidate(12, cullArea = $$new_props.cullArea);
    if ("cursor" in $$new_props) $$invalidate(13, cursor = $$new_props.cursor);
    if ("eventMode" in $$new_props) $$invalidate(14, eventMode = $$new_props.eventMode);
    if ("filterArea" in $$new_props) $$invalidate(15, filterArea = $$new_props.filterArea);
    if ("filters" in $$new_props) $$invalidate(16, filters = $$new_props.filters);
    if ("height" in $$new_props) $$invalidate(17, height = $$new_props.height);
    if ("hitArea" in $$new_props) $$invalidate(18, hitArea = $$new_props.hitArea);
    if ("interactive" in $$new_props) $$invalidate(19, interactive = $$new_props.interactive);
    if ("interactiveChildren" in $$new_props) $$invalidate(20, interactiveChildren = $$new_props.interactiveChildren);
    if ("isMask" in $$new_props) $$invalidate(21, isMask = $$new_props.isMask);
    if ("isSprite" in $$new_props) $$invalidate(22, isSprite = $$new_props.isSprite);
    if ("mask" in $$new_props) $$invalidate(23, mask = $$new_props.mask);
    if ("name" in $$new_props) $$invalidate(24, name = $$new_props.name);
    if ("pivot" in $$new_props) $$invalidate(25, pivot = $$new_props.pivot);
    if ("position" in $$new_props) $$invalidate(26, position = $$new_props.position);
    if ("renderable" in $$new_props) $$invalidate(27, renderable = $$new_props.renderable);
    if ("rotation" in $$new_props) $$invalidate(28, rotation = $$new_props.rotation);
    if ("scale" in $$new_props) $$invalidate(29, scale = $$new_props.scale);
    if ("skew" in $$new_props) $$invalidate(30, skew = $$new_props.skew);
    if ("sortableChildren" in $$new_props) $$invalidate(31, sortableChildren = $$new_props.sortableChildren);
    if ("width" in $$new_props) $$invalidate(32, width = $$new_props.width);
    if ("transform" in $$new_props) $$invalidate(33, transform = $$new_props.transform);
    if ("visible" in $$new_props) $$invalidate(34, visible = $$new_props.visible);
    if ("x" in $$new_props) $$invalidate(35, x = $$new_props.x);
    if ("y" in $$new_props) $$invalidate(36, y = $$new_props.y);
    if ("zIndex" in $$new_props) $$invalidate(37, zIndex = $$new_props.zIndex);
    if ("instance" in $$new_props) $$invalidate(38, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(39, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContainer,
    getStage,
    PIXI: lib_exports,
    afterUpdate,
    createEventDispatcher,
    getContext,
    onMount,
    setContext,
    getRenderer,
    createApplyProps,
    accessible,
    accessibleChildren,
    accessibleHint,
    accessiblePointerEvents,
    accessibleTitle,
    accessibleType,
    alpha,
    angle,
    cacheAsBitmap,
    cacheAsBitmapMultisample,
    cacheAsBitmapResolution,
    cullable,
    cullArea,
    cursor,
    eventMode,
    filterArea,
    filters,
    height,
    hitArea,
    interactive,
    interactiveChildren,
    isMask,
    isSprite,
    mask,
    name,
    pivot,
    position,
    renderable,
    rotation,
    scale,
    skew,
    sortableChildren,
    width,
    transform,
    visible,
    x,
    y,
    zIndex,
    instance: instance2,
    applyProp: applyProp2,
    applyProps: applyProps2,
    invalidate,
    parent,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(46, $$props = assign(assign({}, $$props), $$new_props));
    if ("accessible" in $$props) $$invalidate(0, accessible = $$new_props.accessible);
    if ("accessibleChildren" in $$props) $$invalidate(1, accessibleChildren = $$new_props.accessibleChildren);
    if ("accessibleHint" in $$props) $$invalidate(2, accessibleHint = $$new_props.accessibleHint);
    if ("accessiblePointerEvents" in $$props) $$invalidate(3, accessiblePointerEvents = $$new_props.accessiblePointerEvents);
    if ("accessibleTitle" in $$props) $$invalidate(4, accessibleTitle = $$new_props.accessibleTitle);
    if ("accessibleType" in $$props) $$invalidate(5, accessibleType = $$new_props.accessibleType);
    if ("alpha" in $$props) $$invalidate(6, alpha = $$new_props.alpha);
    if ("angle" in $$props) $$invalidate(7, angle = $$new_props.angle);
    if ("cacheAsBitmap" in $$props) $$invalidate(8, cacheAsBitmap = $$new_props.cacheAsBitmap);
    if ("cacheAsBitmapMultisample" in $$props) $$invalidate(9, cacheAsBitmapMultisample = $$new_props.cacheAsBitmapMultisample);
    if ("cacheAsBitmapResolution" in $$props) $$invalidate(10, cacheAsBitmapResolution = $$new_props.cacheAsBitmapResolution);
    if ("cullable" in $$props) $$invalidate(11, cullable = $$new_props.cullable);
    if ("cullArea" in $$props) $$invalidate(12, cullArea = $$new_props.cullArea);
    if ("cursor" in $$props) $$invalidate(13, cursor = $$new_props.cursor);
    if ("eventMode" in $$props) $$invalidate(14, eventMode = $$new_props.eventMode);
    if ("filterArea" in $$props) $$invalidate(15, filterArea = $$new_props.filterArea);
    if ("filters" in $$props) $$invalidate(16, filters = $$new_props.filters);
    if ("height" in $$props) $$invalidate(17, height = $$new_props.height);
    if ("hitArea" in $$props) $$invalidate(18, hitArea = $$new_props.hitArea);
    if ("interactive" in $$props) $$invalidate(19, interactive = $$new_props.interactive);
    if ("interactiveChildren" in $$props) $$invalidate(20, interactiveChildren = $$new_props.interactiveChildren);
    if ("isMask" in $$props) $$invalidate(21, isMask = $$new_props.isMask);
    if ("isSprite" in $$props) $$invalidate(22, isSprite = $$new_props.isSprite);
    if ("mask" in $$props) $$invalidate(23, mask = $$new_props.mask);
    if ("name" in $$props) $$invalidate(24, name = $$new_props.name);
    if ("pivot" in $$props) $$invalidate(25, pivot = $$new_props.pivot);
    if ("position" in $$props) $$invalidate(26, position = $$new_props.position);
    if ("renderable" in $$props) $$invalidate(27, renderable = $$new_props.renderable);
    if ("rotation" in $$props) $$invalidate(28, rotation = $$new_props.rotation);
    if ("scale" in $$props) $$invalidate(29, scale = $$new_props.scale);
    if ("skew" in $$props) $$invalidate(30, skew = $$new_props.skew);
    if ("sortableChildren" in $$props) $$invalidate(31, sortableChildren = $$new_props.sortableChildren);
    if ("width" in $$props) $$invalidate(32, width = $$new_props.width);
    if ("transform" in $$props) $$invalidate(33, transform = $$new_props.transform);
    if ("visible" in $$props) $$invalidate(34, visible = $$new_props.visible);
    if ("x" in $$props) $$invalidate(35, x = $$new_props.x);
    if ("y" in $$props) $$invalidate(36, y = $$new_props.y);
    if ("zIndex" in $$props) $$invalidate(37, zIndex = $$new_props.zIndex);
    if ("instance" in $$props) $$invalidate(38, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*accessible*/
    1) {
      $: applyProp2("accessible", accessible);
    }
    if ($$self.$$.dirty[0] & /*accessibleChildren*/
    2) {
      $: applyProp2("accessibleChildren", accessibleChildren);
    }
    if ($$self.$$.dirty[0] & /*accessibleHint*/
    4) {
      $: applyProp2("accessibleHint", accessibleHint);
    }
    if ($$self.$$.dirty[0] & /*accessiblePointerEvents*/
    8) {
      $: applyProp2("accessiblePointerEvents", accessiblePointerEvents);
    }
    if ($$self.$$.dirty[0] & /*accessibleTitle*/
    16) {
      $: applyProp2("accessibleTitle", accessibleTitle);
    }
    if ($$self.$$.dirty[0] & /*accessibleType*/
    32) {
      $: applyProp2("accessibleType", accessibleType);
    }
    if ($$self.$$.dirty[0] & /*alpha*/
    64) {
      $: applyProp2("alpha", alpha);
    }
    if ($$self.$$.dirty[0] & /*angle*/
    128) {
      $: applyProp2("angle", angle);
    }
    if ($$self.$$.dirty[0] & /*cacheAsBitmap*/
    256) {
      $: applyProp2("cacheAsBitmap", cacheAsBitmap);
    }
    if ($$self.$$.dirty[0] & /*cacheAsBitmapResolution*/
    1024) {
      $: applyProp2("cacheAsBitmapResolution", cacheAsBitmapResolution);
    }
    if ($$self.$$.dirty[0] & /*cacheAsBitmapMultisample*/
    512) {
      $: applyProp2("cacheAsBitmapMultisample", cacheAsBitmapMultisample);
    }
    if ($$self.$$.dirty[0] & /*cursor*/
    8192) {
      $: applyProp2("cursor", cursor);
    }
    if ($$self.$$.dirty[0] & /*cullable*/
    2048) {
      $: applyProp2("cullable", cullable);
    }
    if ($$self.$$.dirty[0] & /*cullArea*/
    4096) {
      $: applyProp2("cullArea", cullArea);
    }
    if ($$self.$$.dirty[0] & /*eventMode*/
    16384) {
      $: applyProp2("eventMode", eventMode);
    }
    if ($$self.$$.dirty[0] & /*filterArea*/
    32768) {
      $: applyProp2("filterArea", filterArea);
    }
    if ($$self.$$.dirty[0] & /*hitArea*/
    262144) {
      $: applyProp2("hitArea", hitArea);
    }
    if ($$self.$$.dirty[0] & /*filters*/
    65536) {
      $: applyProp2("filters", filters);
    }
    if ($$self.$$.dirty[0] & /*height*/
    131072) {
      $: applyProp2("height", height);
    }
    if ($$self.$$.dirty[0] & /*isMask*/
    2097152) {
      $: applyProp2("isMask", isMask);
    }
    if ($$self.$$.dirty[0] & /*isSprite*/
    4194304) {
      $: applyProp2("isSprite", isSprite);
    }
    if ($$self.$$.dirty[0] & /*interactive*/
    524288) {
      $: applyProp2("interactive", interactive);
    }
    if ($$self.$$.dirty[0] & /*interactiveChildren*/
    1048576) {
      $: applyProp2("interactiveChildren", interactiveChildren);
    }
    if ($$self.$$.dirty[0] & /*mask*/
    8388608) {
      $: applyProp2("mask", mask);
    }
    if ($$self.$$.dirty[0] & /*name*/
    16777216) {
      $: applyProp2("name", name);
    }
    if ($$self.$$.dirty[0] & /*pivot*/
    33554432) {
      $: applyProp2("pivot", pivot);
    }
    if ($$self.$$.dirty[0] & /*position*/
    67108864) {
      $: applyProp2("position", position);
    }
    if ($$self.$$.dirty[0] & /*renderable*/
    134217728) {
      $: applyProp2("renderable", renderable);
    }
    if ($$self.$$.dirty[0] & /*rotation*/
    268435456) {
      $: applyProp2("rotation", rotation);
    }
    if ($$self.$$.dirty[0] & /*scale*/
    536870912) {
      $: applyProp2("scale", scale);
    }
    if ($$self.$$.dirty[0] & /*skew*/
    1073741824) {
      $: applyProp2("skew", skew);
    }
    if ($$self.$$.dirty[1] & /*sortableChildren*/
    1) {
      $: applyProp2("sortableChildren", sortableChildren);
    }
    if ($$self.$$.dirty[1] & /*transform*/
    4) {
      $: applyProp2("transform", transform);
    }
    if ($$self.$$.dirty[1] & /*visible*/
    8) {
      $: applyProp2("visible", visible);
    }
    if ($$self.$$.dirty[1] & /*x*/
    16) {
      $: applyProp2("x", x);
    }
    if ($$self.$$.dirty[1] & /*y*/
    32) {
      $: applyProp2("y", y);
    }
    if ($$self.$$.dirty[1] & /*width*/
    2) {
      $: applyProp2("width", width);
    }
    if ($$self.$$.dirty[1] & /*zIndex*/
    64) {
      $: applyProp2("zIndex", zIndex);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    accessible,
    accessibleChildren,
    accessibleHint,
    accessiblePointerEvents,
    accessibleTitle,
    accessibleType,
    alpha,
    angle,
    cacheAsBitmap,
    cacheAsBitmapMultisample,
    cacheAsBitmapResolution,
    cullable,
    cullArea,
    cursor,
    eventMode,
    filterArea,
    filters,
    height,
    hitArea,
    interactive,
    interactiveChildren,
    isMask,
    isSprite,
    mask,
    name,
    pivot,
    position,
    renderable,
    rotation,
    scale,
    skew,
    sortableChildren,
    width,
    transform,
    visible,
    x,
    y,
    zIndex,
    instance2,
    $$scope,
    slots
  ];
}
var Container2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_13,
      create_fragment3,
      safe_not_equal,
      {
        accessible: 0,
        accessibleChildren: 1,
        accessibleHint: 2,
        accessiblePointerEvents: 3,
        accessibleTitle: 4,
        accessibleType: 5,
        alpha: 6,
        angle: 7,
        cacheAsBitmap: 8,
        cacheAsBitmapMultisample: 9,
        cacheAsBitmapResolution: 10,
        cullable: 11,
        cullArea: 12,
        cursor: 13,
        eventMode: 14,
        filterArea: 15,
        filters: 16,
        height: 17,
        hitArea: 18,
        interactive: 19,
        interactiveChildren: 20,
        isMask: 21,
        isSprite: 22,
        mask: 23,
        name: 24,
        pivot: 25,
        position: 26,
        renderable: 27,
        rotation: 28,
        scale: 29,
        skew: 30,
        sortableChildren: 31,
        width: 32,
        transform: 33,
        visible: 34,
        x: 35,
        y: 36,
        zIndex: 37,
        instance: 38
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment3.name
    });
  }
  get accessible() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessible(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accessibleChildren() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessibleChildren(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accessibleHint() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessibleHint(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accessiblePointerEvents() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessiblePointerEvents(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accessibleTitle() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessibleTitle(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accessibleType() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accessibleType(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alpha() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alpha(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get angle() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set angle(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cacheAsBitmap() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cacheAsBitmap(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cacheAsBitmapMultisample() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cacheAsBitmapMultisample(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cacheAsBitmapResolution() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cacheAsBitmapResolution(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cullable() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cullable(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cullArea() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cullArea(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cursor() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cursor(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventMode() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventMode(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterArea() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterArea(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filters() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filters(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hitArea() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hitArea(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactiveChildren() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactiveChildren(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isMask() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isMask(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSprite() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSprite(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mask() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mask(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pivot() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pivot(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderable() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderable(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skew() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skew(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortableChildren() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortableChildren(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container2;

// node_modules/svelte-pixi/dist/AnimatedSprite.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(106:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[12]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[13]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[14]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[15]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[16]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[17]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[18]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[19]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[20]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[21]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[22]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[23]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[24]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[25]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[27]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[28]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[29]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[30]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[31]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[32]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[33]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[34]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[35]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[36]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[37]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[38]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[39]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[40]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[41]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[42]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[43]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[44]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      16384) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_14($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "anchor",
    "blendMode",
    "pluginName",
    "roundPixels",
    "autoUpdate",
    "animationSpeed",
    "loop",
    "playing",
    "textures",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimatedSprite", slots, ["default"]);
  let { anchor = void 0 } = $$props;
  let { blendMode = BLEND_MODES.NORMAL } = $$props;
  let { pluginName = void 0 } = $$props;
  let { roundPixels = void 0 } = $$props;
  let { autoUpdate = void 0 } = $$props;
  let { animationSpeed = 1 } = $$props;
  let { loop = true } = $$props;
  let { playing = true } = $$props;
  let { textures = [] } = $$props;
  let { instance: instance2 = new AnimatedSprite(textures, autoUpdate) } = $$props;
  const { applyProp: applyProp2 } = createApplyProps(instance2, {
    textures: (value, instance3) => {
      instance3.textures = value;
      if (playing) {
        instance3.play();
      }
    },
    playing: (value, instance3) => {
      if (playing) {
        instance3.play();
      } else {
        instance3.stop();
      }
    }
  });
  const dispatch = createEventDispatcher();
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  onMount(() => {
    $$invalidate(0, instance2.onComplete = () => dispatch("complete"), instance2);
    $$invalidate(
      0,
      instance2.onFrameChange = () => {
        dispatch("frameChange");
        invalidate();
      },
      instance2
    );
    $$invalidate(0, instance2.onLoop = () => dispatch("loop"), instance2);
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("anchor" in $$new_props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("blendMode" in $$new_props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$new_props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$new_props) $$invalidate(5, roundPixels = $$new_props.roundPixels);
    if ("autoUpdate" in $$new_props) $$invalidate(6, autoUpdate = $$new_props.autoUpdate);
    if ("animationSpeed" in $$new_props) $$invalidate(7, animationSpeed = $$new_props.animationSpeed);
    if ("loop" in $$new_props) $$invalidate(8, loop = $$new_props.loop);
    if ("playing" in $$new_props) $$invalidate(9, playing = $$new_props.playing);
    if ("textures" in $$new_props) $$invalidate(10, textures = $$new_props.textures);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(45, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    createEventDispatcher,
    onMount,
    getRenderer,
    Container: Container_default,
    createApplyProps,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    autoUpdate,
    animationSpeed,
    loop,
    playing,
    textures,
    instance: instance2,
    applyProp: applyProp2,
    dispatch,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("anchor" in $$props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("blendMode" in $$props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$props) $$invalidate(5, roundPixels = $$new_props.roundPixels);
    if ("autoUpdate" in $$props) $$invalidate(6, autoUpdate = $$new_props.autoUpdate);
    if ("animationSpeed" in $$props) $$invalidate(7, animationSpeed = $$new_props.animationSpeed);
    if ("loop" in $$props) $$invalidate(8, loop = $$new_props.loop);
    if ("playing" in $$props) $$invalidate(9, playing = $$new_props.playing);
    if ("textures" in $$props) $$invalidate(10, textures = $$new_props.textures);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*anchor*/
    4) {
      $: applyProp2("anchor", anchor);
    }
    if ($$self.$$.dirty[0] & /*blendMode*/
    8) {
      $: applyProp2("blendMode", blendMode);
    }
    if ($$self.$$.dirty[0] & /*pluginName*/
    16) {
      $: applyProp2("pluginName", pluginName);
    }
    if ($$self.$$.dirty[0] & /*roundPixels*/
    32) {
      $: applyProp2("roundPixels", roundPixels);
    }
    if ($$self.$$.dirty[0] & /*autoUpdate*/
    64) {
      $: applyProp2("autoUpdate", autoUpdate);
    }
    if ($$self.$$.dirty[0] & /*animationSpeed*/
    128) {
      $: applyProp2("animationSpeed", animationSpeed);
    }
    if ($$self.$$.dirty[0] & /*loop*/
    256) {
      $: applyProp2("loop", loop);
    }
    if ($$self.$$.dirty[0] & /*textures*/
    1024) {
      $: applyProp2("textures", textures);
    }
    if ($$self.$$.dirty[0] & /*playing*/
    512) {
      $: applyProp2("playing", playing);
    }
    if ($$self.$$.dirty[0] & /*textures*/
    1024) {
      $: textures.forEach((texture) => texture.on("update", invalidate));
    }
  };
  return [
    instance2,
    $$restProps,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    autoUpdate,
    animationSpeed,
    loop,
    playing,
    textures,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var AnimatedSprite2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_14,
      create_fragment4,
      safe_not_equal,
      {
        anchor: 2,
        blendMode: 3,
        pluginName: 4,
        roundPixels: 5,
        autoUpdate: 6,
        animationSpeed: 7,
        loop: 8,
        playing: 9,
        textures: 10,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimatedSprite",
      options,
      id: create_fragment4.name
    });
  }
  get anchor() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blendMode() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blendMode(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pluginName() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pluginName(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundPixels() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundPixels(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoUpdate() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoUpdate(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animationSpeed() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animationSpeed(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playing() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playing(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textures() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textures(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<AnimatedSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<AnimatedSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimatedSprite_default = AnimatedSprite2;

// node_modules/svelte-pixi/dist/AssetsLoader.svelte
var get_loading_slot_changes = (dirty) => ({ progress: dirty & /*progress*/
1 });
var get_loading_slot_context = (ctx) => ({ progress: (
  /*progress*/
  ctx[0]
) });
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(77:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let current;
  const loading_slot_template = (
    /*#slots*/
    ctx[6].loading
  );
  const loading_slot = create_slot(
    loading_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_loading_slot_context
  );
  const block = {
    c: function create() {
      if (loading_slot) loading_slot.c();
    },
    m: function mount(target, anchor) {
      if (loading_slot) {
        loading_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (loading_slot) {
        if (loading_slot.p && (!current || dirty & /*$$scope, progress*/
        33)) {
          update_slot_base(
            loading_slot,
            loading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              loading_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_loading_slot_changes
            ),
            get_loading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(loading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (loading_slot) loading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(75:0) {#if loading}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loading*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var bundleCounter = 0;
function instance($$self, $$props, $$invalidate) {
  let loading;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AssetsLoader", slots, ["loading", "default"]);
  let { assets = [] } = $$props;
  let { bundleName = `svelte-pixi-loader-${++bundleCounter}` } = $$props;
  let { unload = false } = $$props;
  const dispatch = createEventDispatcher();
  const { invalidate } = getRenderer();
  let { progress = 0 } = $$props;
  onMount(() => {
    async function load() {
      const { cache } = Assets;
      Assets.addBundle(bundleName, assets.filter((r) => {
        const key = typeof r === "string" ? r : r.alias;
        return !cache.has(key);
      }).map((r) => {
        if (typeof r === "string") {
          return { alias: r, src: r };
        }
        return r;
      }));
      dispatch("start");
      await Assets.loadBundle(bundleName, (prog) => {
        if (prog < 1) {
          $$invalidate(0, progress = prog);
          dispatch("progress", progress);
        }
      });
      $$invalidate(0, progress = 1);
      dispatch("progress", progress);
      dispatch("complete");
    }
    load();
    return () => {
      if (unload) {
        Assets.unloadBundle(bundleName);
      }
    };
  });
  const writable_props = ["assets", "bundleName", "unload", "progress"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AssetsLoader> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("assets" in $$props2) $$invalidate(2, assets = $$props2.assets);
    if ("bundleName" in $$props2) $$invalidate(3, bundleName = $$props2.bundleName);
    if ("unload" in $$props2) $$invalidate(4, unload = $$props2.unload);
    if ("progress" in $$props2) $$invalidate(0, progress = $$props2.progress);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    bundleCounter,
    Assets,
    createEventDispatcher,
    onMount,
    getRenderer,
    assets,
    bundleName,
    unload,
    dispatch,
    invalidate,
    progress,
    loading
  });
  $$self.$inject_state = ($$props2) => {
    if ("assets" in $$props2) $$invalidate(2, assets = $$props2.assets);
    if ("bundleName" in $$props2) $$invalidate(3, bundleName = $$props2.bundleName);
    if ("unload" in $$props2) $$invalidate(4, unload = $$props2.unload);
    if ("progress" in $$props2) $$invalidate(0, progress = $$props2.progress);
    if ("loading" in $$props2) $$invalidate(1, loading = $$props2.loading);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*progress*/
    1) {
      $: $$invalidate(1, loading = progress < 1);
    }
    if ($$self.$$.dirty & /*progress*/
    1) {
      $: progress, invalidate();
    }
  };
  return [progress, loading, assets, bundleName, unload, $$scope, slots];
}
var AssetsLoader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment5, safe_not_equal, {
      assets: 2,
      bundleName: 3,
      unload: 4,
      progress: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AssetsLoader",
      options,
      id: create_fragment5.name
    });
  }
  get assets() {
    throw new Error("<AssetsLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set assets(value) {
    throw new Error("<AssetsLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bundleName() {
    throw new Error("<AssetsLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bundleName(value) {
    throw new Error("<AssetsLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unload() {
    throw new Error("<AssetsLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unload(value) {
    throw new Error("<AssetsLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get progress() {
    throw new Error("<AssetsLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<AssetsLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AssetsLoader_default = AssetsLoader;

// node_modules/svelte-pixi/dist/Application.svelte
var file2 = "node_modules/svelte-pixi/dist/Application.svelte";
var get_view_slot_changes2 = (dirty) => ({});
var get_view_slot_context2 = (ctx) => ({ slot: "view" });
function create_if_block3(ctx) {
  let ticker;
  let current;
  ticker = new Ticker_default({ $$inline: true });
  ticker.$on(
    "tick",
    /*tick_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(ticker.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(ticker, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(ticker.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(ticker.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(ticker, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(168:2) {#if render}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(183:4) <Container instance={instance.stage}>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let container;
  let current;
  container = new Container_default({
    props: {
      instance: (
        /*instance*/
        ctx[1].stage
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = {};
      if (dirty & /*instance*/
      2) container_changes.instance = /*instance*/
      ctx2[1].stage;
      if (dirty & /*$$scope*/
      33554432) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(182:2) <Ticker instance={instance.ticker}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t;
  let ticker;
  let current;
  let if_block = (
    /*render*/
    ctx[0] && create_if_block3(ctx)
  );
  ticker = new Ticker_default({
    props: {
      instance: (
        /*instance*/
        ctx[1].ticker
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      t = space();
      create_component(ticker.$$.fragment);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      mount_component(ticker, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*render*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*render*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const ticker_changes = {};
      if (dirty & /*instance*/
      2) ticker_changes.instance = /*instance*/
      ctx2[1].ticker;
      if (dirty & /*$$scope, instance*/
      33554434) {
        ticker_changes.$$scope = { dirty, ctx: ctx2 };
      }
      ticker.$set(ticker_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(ticker.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(ticker.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (if_block) if_block.d(detaching);
      destroy_component(ticker, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(156:0) <Renderer   instance={instance.renderer}   on:invalidate={() => {     invalidated = true   }}   on:prerender   on:postrender >",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      add_location(div, file2, 164, 4, 4230);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(164:32)      ",
    ctx
  });
  return block;
}
function create_view_slot(ctx) {
  let current;
  const view_slot_template = (
    /*#slots*/
    ctx[20].view
  );
  const view_slot = create_slot(
    view_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_view_slot_context2
  );
  const view_slot_or_fallback = view_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      if (view_slot_or_fallback) view_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (view_slot_or_fallback) {
        view_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (view_slot) {
        if (view_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            view_slot,
            view_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              view_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_view_slot_changes2
            ),
            get_view_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(view_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(view_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (view_slot_or_fallback) view_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_view_slot.name,
    type: "slot",
    source: "(164:2) ",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let renderer;
  let current;
  renderer = new Renderer_default({
    props: {
      instance: (
        /*instance*/
        ctx[1].renderer
      ),
      $$slots: {
        view: [create_view_slot],
        default: [create_default_slot2]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  renderer.$on(
    "invalidate",
    /*invalidate_handler*/
    ctx[22]
  );
  renderer.$on(
    "prerender",
    /*prerender_handler*/
    ctx[23]
  );
  renderer.$on(
    "postrender",
    /*postrender_handler*/
    ctx[24]
  );
  const block = {
    c: function create() {
      create_component(renderer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(renderer, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const renderer_changes = {};
      if (dirty & /*instance*/
      2) renderer_changes.instance = /*instance*/
      ctx2[1].renderer;
      if (dirty & /*$$scope, instance, render, invalidated*/
      33554439) {
        renderer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      renderer.$set(renderer_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(renderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(renderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getApp() {
  return getContext("pixi/app") ?? {};
}
function instance_15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Application", slots, ["view", "default"]);
  let { autoStart = true } = $$props;
  let { width = 800 } = $$props;
  let { height = 600 } = $$props;
  let { useContextAlpha = void 0 } = $$props;
  let { autoDensity = true } = $$props;
  let { antialias = false } = $$props;
  let { preserveDrawingBuffer = false } = $$props;
  let { resolution = settings.RESOLUTION } = $$props;
  let { forceCanvas = false } = $$props;
  let { backgroundColor = 0 } = $$props;
  let { backgroundAlpha = 1 } = $$props;
  let { clearBeforeRender = void 0 } = $$props;
  let { eventMode = void 0 } = $$props;
  let { eventFeatures = void 0 } = $$props;
  let { powerPreference = void 0 } = $$props;
  let { premultipliedAlpha = void 0 } = $$props;
  let { resizeTo = void 0 } = $$props;
  let { render = "auto" } = $$props;
  let { instance: instance2 = new Application(
    // some props being explicitly undefined different behaviour than implicit
    // undefined
    omitUndefined({
      autoStart,
      width,
      height,
      useContextAlpha,
      premultipliedAlpha,
      autoDensity,
      antialias,
      preserveDrawingBuffer,
      resolution,
      forceCanvas,
      backgroundColor,
      backgroundAlpha,
      clearBeforeRender,
      powerPreference,
      resizeTo,
      eventMode,
      eventFeatures
    })
  ) } = $$props;
  let invalidated = true;
  setContext("pixi/app", { app: instance2 });
  if (render) {
    instance2.ticker.remove(instance2.render, instance2);
  }
  const writable_props = [
    "autoStart",
    "width",
    "height",
    "useContextAlpha",
    "autoDensity",
    "antialias",
    "preserveDrawingBuffer",
    "resolution",
    "forceCanvas",
    "backgroundColor",
    "backgroundAlpha",
    "clearBeforeRender",
    "eventMode",
    "eventFeatures",
    "powerPreference",
    "premultipliedAlpha",
    "resizeTo",
    "render",
    "instance"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Application> was created with unknown prop '${key}'`);
  });
  const tick_handler = () => {
    if (render === "demand") {
      if (invalidated) {
        $$invalidate(2, invalidated = false);
        instance2.renderer.render(instance2.stage);
      }
    } else if (render === "auto") {
      instance2.renderer.render(instance2.stage);
    }
  };
  const invalidate_handler = () => {
    $$invalidate(2, invalidated = true);
  };
  function prerender_handler(event) {
    bubble.call(this, $$self, event);
  }
  function postrender_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("autoStart" in $$props2) $$invalidate(3, autoStart = $$props2.autoStart);
    if ("width" in $$props2) $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(5, height = $$props2.height);
    if ("useContextAlpha" in $$props2) $$invalidate(6, useContextAlpha = $$props2.useContextAlpha);
    if ("autoDensity" in $$props2) $$invalidate(7, autoDensity = $$props2.autoDensity);
    if ("antialias" in $$props2) $$invalidate(8, antialias = $$props2.antialias);
    if ("preserveDrawingBuffer" in $$props2) $$invalidate(9, preserveDrawingBuffer = $$props2.preserveDrawingBuffer);
    if ("resolution" in $$props2) $$invalidate(10, resolution = $$props2.resolution);
    if ("forceCanvas" in $$props2) $$invalidate(11, forceCanvas = $$props2.forceCanvas);
    if ("backgroundColor" in $$props2) $$invalidate(12, backgroundColor = $$props2.backgroundColor);
    if ("backgroundAlpha" in $$props2) $$invalidate(13, backgroundAlpha = $$props2.backgroundAlpha);
    if ("clearBeforeRender" in $$props2) $$invalidate(14, clearBeforeRender = $$props2.clearBeforeRender);
    if ("eventMode" in $$props2) $$invalidate(15, eventMode = $$props2.eventMode);
    if ("eventFeatures" in $$props2) $$invalidate(16, eventFeatures = $$props2.eventFeatures);
    if ("powerPreference" in $$props2) $$invalidate(17, powerPreference = $$props2.powerPreference);
    if ("premultipliedAlpha" in $$props2) $$invalidate(18, premultipliedAlpha = $$props2.premultipliedAlpha);
    if ("resizeTo" in $$props2) $$invalidate(19, resizeTo = $$props2.resizeTo);
    if ("render" in $$props2) $$invalidate(0, render = $$props2.render);
    if ("instance" in $$props2) $$invalidate(1, instance2 = $$props2.instance);
    if ("$$scope" in $$props2) $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getApp,
    PIXI: lib_exports,
    getContext,
    setContext,
    Container: Container_default,
    Renderer: Renderer_default,
    Ticker: Ticker_default,
    omitUndefined,
    autoStart,
    width,
    height,
    useContextAlpha,
    autoDensity,
    antialias,
    preserveDrawingBuffer,
    resolution,
    forceCanvas,
    backgroundColor,
    backgroundAlpha,
    clearBeforeRender,
    eventMode,
    eventFeatures,
    powerPreference,
    premultipliedAlpha,
    resizeTo,
    render,
    instance: instance2,
    invalidated
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoStart" in $$props2) $$invalidate(3, autoStart = $$props2.autoStart);
    if ("width" in $$props2) $$invalidate(4, width = $$props2.width);
    if ("height" in $$props2) $$invalidate(5, height = $$props2.height);
    if ("useContextAlpha" in $$props2) $$invalidate(6, useContextAlpha = $$props2.useContextAlpha);
    if ("autoDensity" in $$props2) $$invalidate(7, autoDensity = $$props2.autoDensity);
    if ("antialias" in $$props2) $$invalidate(8, antialias = $$props2.antialias);
    if ("preserveDrawingBuffer" in $$props2) $$invalidate(9, preserveDrawingBuffer = $$props2.preserveDrawingBuffer);
    if ("resolution" in $$props2) $$invalidate(10, resolution = $$props2.resolution);
    if ("forceCanvas" in $$props2) $$invalidate(11, forceCanvas = $$props2.forceCanvas);
    if ("backgroundColor" in $$props2) $$invalidate(12, backgroundColor = $$props2.backgroundColor);
    if ("backgroundAlpha" in $$props2) $$invalidate(13, backgroundAlpha = $$props2.backgroundAlpha);
    if ("clearBeforeRender" in $$props2) $$invalidate(14, clearBeforeRender = $$props2.clearBeforeRender);
    if ("eventMode" in $$props2) $$invalidate(15, eventMode = $$props2.eventMode);
    if ("eventFeatures" in $$props2) $$invalidate(16, eventFeatures = $$props2.eventFeatures);
    if ("powerPreference" in $$props2) $$invalidate(17, powerPreference = $$props2.powerPreference);
    if ("premultipliedAlpha" in $$props2) $$invalidate(18, premultipliedAlpha = $$props2.premultipliedAlpha);
    if ("resizeTo" in $$props2) $$invalidate(19, resizeTo = $$props2.resizeTo);
    if ("render" in $$props2) $$invalidate(0, render = $$props2.render);
    if ("instance" in $$props2) $$invalidate(1, instance2 = $$props2.instance);
    if ("invalidated" in $$props2) $$invalidate(2, invalidated = $$props2.invalidated);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    render,
    instance2,
    invalidated,
    autoStart,
    width,
    height,
    useContextAlpha,
    autoDensity,
    antialias,
    preserveDrawingBuffer,
    resolution,
    forceCanvas,
    backgroundColor,
    backgroundAlpha,
    clearBeforeRender,
    eventMode,
    eventFeatures,
    powerPreference,
    premultipliedAlpha,
    resizeTo,
    slots,
    tick_handler,
    invalidate_handler,
    prerender_handler,
    postrender_handler,
    $$scope
  ];
}
var Application2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_15, create_fragment6, safe_not_equal, {
      autoStart: 3,
      width: 4,
      height: 5,
      useContextAlpha: 6,
      autoDensity: 7,
      antialias: 8,
      preserveDrawingBuffer: 9,
      resolution: 10,
      forceCanvas: 11,
      backgroundColor: 12,
      backgroundAlpha: 13,
      clearBeforeRender: 14,
      eventMode: 15,
      eventFeatures: 16,
      powerPreference: 17,
      premultipliedAlpha: 18,
      resizeTo: 19,
      render: 0,
      instance: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Application",
      options,
      id: create_fragment6.name
    });
  }
  get autoStart() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoStart(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useContextAlpha() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useContextAlpha(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoDensity() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoDensity(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get antialias() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set antialias(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preserveDrawingBuffer() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preserveDrawingBuffer(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resolution() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resolution(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forceCanvas() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forceCanvas(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundAlpha() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundAlpha(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearBeforeRender() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearBeforeRender(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventMode() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventMode(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eventFeatures() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eventFeatures(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get powerPreference() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set powerPreference(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get premultipliedAlpha() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set premultipliedAlpha(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizeTo() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizeTo(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get render() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set render(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Application>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Application>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Application_default = Application2;

// node_modules/svelte-pixi/dist/BitmapText.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[39],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[39]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[39],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(59:0) <Container   {...$$restProps}   {instance}   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "click",
    /*click_handler*/
    ctx[7]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[8]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[9]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[10]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[11]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[12]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[13]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[14]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[15]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[16]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[17]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[18]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[19]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[20]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[21]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[22]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[23]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[24]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[25]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[26]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[27]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[28]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[29]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[30]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[31]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[32]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[33]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[34]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[35]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[36]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[37]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[38]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      256) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_16($$self, $$props, $$invalidate) {
  const omit_props_names = ["anchor", "text", "roundPixels", "style", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BitmapText", slots, ["default"]);
  let { anchor = void 0 } = $$props;
  let { text } = $$props;
  let { roundPixels = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { instance: instance2 = new BitmapText(text, style) } = $$props;
  const { applyProp: applyProp2, applyProps: applyProps2 } = createApplyProps(instance2);
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (text === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<BitmapText> was created without expected prop 'text'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("anchor" in $$new_props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("text" in $$new_props) $$invalidate(3, text = $$new_props.text);
    if ("roundPixels" in $$new_props) $$invalidate(4, roundPixels = $$new_props.roundPixels);
    if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(39, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    omitUndefined,
    createApplyProps,
    anchor,
    text,
    roundPixels,
    style,
    instance: instance2,
    applyProp: applyProp2,
    applyProps: applyProps2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("anchor" in $$props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("text" in $$props) $$invalidate(3, text = $$new_props.text);
    if ("roundPixels" in $$props) $$invalidate(4, roundPixels = $$new_props.roundPixels);
    if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*anchor*/
    4) {
      $: applyProp2("anchor", anchor);
    }
    if ($$self.$$.dirty[0] & /*roundPixels*/
    16) {
      $: applyProp2("roundPixels", roundPixels);
    }
    if ($$self.$$.dirty[0] & /*text*/
    8) {
      $: applyProp2("text", text);
    }
    if ($$self.$$.dirty[0] & /*style*/
    32) {
      $: applyProps2(omitUndefined({
        align: style == null ? void 0 : style.align,
        fontName: style == null ? void 0 : style.fontName,
        fontSize: style == null ? void 0 : style.fontSize,
        tint: style == null ? void 0 : style.tint,
        letterSpacing: style == null ? void 0 : style.letterSpacing,
        maxWidth: style == null ? void 0 : style.maxWidth
      }));
    }
  };
  return [
    instance2,
    $$restProps,
    anchor,
    text,
    roundPixels,
    style,
    slots,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var BitmapText2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_16,
      create_fragment7,
      safe_not_equal,
      {
        anchor: 2,
        text: 3,
        roundPixels: 4,
        style: 5,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BitmapText",
      options,
      id: create_fragment7.name
    });
  }
  get anchor() {
    throw new Error("<BitmapText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<BitmapText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<BitmapText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<BitmapText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundPixels() {
    throw new Error("<BitmapText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundPixels(value) {
    throw new Error("<BitmapText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<BitmapText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<BitmapText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<BitmapText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<BitmapText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BitmapText_default = BitmapText2;

// node_modules/svelte-pixi/dist/Graphics.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(53:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[7]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[8]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[9]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[10]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[11]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[12]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[13]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[14]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[15]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[16]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[17]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[18]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[19]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[20]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[21]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[22]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[23]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[24]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[25]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[26]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[27]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[28]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[29]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[30]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[31]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[32]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[33]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[34]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[35]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[36]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[37]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[38]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[39]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      512) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_17($$self, $$props, $$invalidate) {
  const omit_props_names = ["draw", "blendMode", "pluginName", "tint", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Graphics", slots, ["default"]);
  let { draw = void 0 } = $$props;
  let { blendMode = BLEND_MODES.NORMAL } = $$props;
  let { pluginName = void 0 } = $$props;
  let { tint = 16777215 } = $$props;
  let { instance: instance2 = new Graphics() } = $$props;
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("draw" in $$new_props) $$invalidate(2, draw = $$new_props.draw);
    if ("blendMode" in $$new_props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$new_props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("tint" in $$new_props) $$invalidate(5, tint = $$new_props.tint);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(40, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    createApplyProps,
    draw,
    blendMode,
    pluginName,
    tint,
    instance: instance2,
    invalidate,
    applyProp: applyProp2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("draw" in $$props) $$invalidate(2, draw = $$new_props.draw);
    if ("blendMode" in $$props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("tint" in $$props) $$invalidate(5, tint = $$new_props.tint);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*blendMode*/
    8) {
      $: applyProp2("blendMode", blendMode);
    }
    if ($$self.$$.dirty[0] & /*pluginName*/
    16) {
      $: applyProp2("pluginName", pluginName);
    }
    if ($$self.$$.dirty[0] & /*tint*/
    32) {
      $: applyProp2("tint", tint);
    }
    if ($$self.$$.dirty[0] & /*draw, instance*/
    5) {
      $: draw == null ? void 0 : draw(instance2);
    }
  };
  return [
    instance2,
    $$restProps,
    draw,
    blendMode,
    pluginName,
    tint,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var Graphics2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_17,
      create_fragment8,
      safe_not_equal,
      {
        draw: 2,
        blendMode: 3,
        pluginName: 4,
        tint: 5,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Graphics",
      options,
      id: create_fragment8.name
    });
  }
  get draw() {
    throw new Error("<Graphics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set draw(value) {
    throw new Error("<Graphics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blendMode() {
    throw new Error("<Graphics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blendMode(value) {
    throw new Error("<Graphics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pluginName() {
    throw new Error("<Graphics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pluginName(value) {
    throw new Error("<Graphics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tint() {
    throw new Error("<Graphics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tint(value) {
    throw new Error("<Graphics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Graphics>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Graphics>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Graphics_default = Graphics2;

// node_modules/svelte-pixi/dist/HTMLText.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[42],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[42],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[42]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[42],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(65:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[9]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[11]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[12]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[13]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[14]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[15]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[16]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[17]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[18]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[19]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[20]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[21]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[22]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[23]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[24]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[25]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[26]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[27]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[28]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[29]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[30]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[31]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[32]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[33]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[34]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[35]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[36]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[37]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[38]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[39]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[40]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[41]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2048) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_18($$self, $$props, $$invalidate) {
  const omit_props_names = ["text", "style", "anchor", "blendMode", "pluginName", "roundPixels", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HTMLText", slots, ["default"]);
  let { text } = $$props;
  let { style = void 0 } = $$props;
  let { anchor = void 0 } = $$props;
  let { blendMode = BLEND_MODES.NORMAL } = $$props;
  let { pluginName = void 0 } = $$props;
  let { roundPixels = void 0 } = $$props;
  let { instance: instance2 = new HTMLText(text, style) } = $$props;
  const { invalidate } = getRenderer();
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (text === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<HTMLText> was created without expected prop 'text'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
    if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    if ("anchor" in $$new_props) $$invalidate(4, anchor = $$new_props.anchor);
    if ("blendMode" in $$new_props) $$invalidate(5, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$new_props) $$invalidate(6, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$new_props) $$invalidate(7, roundPixels = $$new_props.roundPixels);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(42, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    createApplyProps,
    Container: Container_default,
    afterUpdate,
    getRenderer,
    text,
    style,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    instance: instance2,
    invalidate,
    applyProp: applyProp2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
    if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    if ("anchor" in $$props) $$invalidate(4, anchor = $$new_props.anchor);
    if ("blendMode" in $$props) $$invalidate(5, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$props) $$invalidate(6, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$props) $$invalidate(7, roundPixels = $$new_props.roundPixels);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*text*/
    4) {
      $: applyProp2("text", text);
    }
    if ($$self.$$.dirty[0] & /*style*/
    8) {
      $: applyProp2("style", style);
    }
    if ($$self.$$.dirty[0] & /*anchor*/
    16) {
      $: applyProp2("anchor", anchor);
    }
    if ($$self.$$.dirty[0] & /*blendMode*/
    32) {
      $: applyProp2("blendMode", blendMode);
    }
    if ($$self.$$.dirty[0] & /*pluginName*/
    64) {
      $: applyProp2("pluginName", pluginName);
    }
    if ($$self.$$.dirty[0] & /*roundPixels*/
    128) {
      $: applyProp2("roundPixels", roundPixels);
    }
  };
  return [
    instance2,
    $$restProps,
    text,
    style,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var HTMLText2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_18,
      create_fragment9,
      safe_not_equal,
      {
        text: 2,
        style: 3,
        anchor: 4,
        blendMode: 5,
        pluginName: 6,
        roundPixels: 7,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HTMLText",
      options,
      id: create_fragment9.name
    });
  }
  get text() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blendMode() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blendMode(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pluginName() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pluginName(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundPixels() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundPixels(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<HTMLText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<HTMLText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HTMLText_default = HTMLText2;

// node_modules/svelte-pixi/dist/Mesh.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(55:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[7]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[8]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[9]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[10]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[11]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[12]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[13]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[14]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[15]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[16]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[17]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[18]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[19]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[20]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[21]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[22]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[23]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[24]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[25]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[26]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[27]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[28]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[29]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[30]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[31]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[32]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[33]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[34]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[35]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[36]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[37]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[38]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[39]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      512) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_19($$self, $$props, $$invalidate) {
  const omit_props_names = ["geometry", "shader", "state", "drawMode", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mesh", slots, ["default"]);
  let { geometry } = $$props;
  let { shader } = $$props;
  let { state = void 0 } = $$props;
  let { drawMode = void 0 } = $$props;
  let { instance: instance2 = new Mesh(geometry, shader, state, drawMode) } = $$props;
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (geometry === void 0 && !("geometry" in $$props || $$self.$$.bound[$$self.$$.props["geometry"]])) {
      console.warn("<Mesh> was created without expected prop 'geometry'");
    }
    if (shader === void 0 && !("shader" in $$props || $$self.$$.bound[$$self.$$.props["shader"]])) {
      console.warn("<Mesh> was created without expected prop 'shader'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("geometry" in $$new_props) $$invalidate(2, geometry = $$new_props.geometry);
    if ("shader" in $$new_props) $$invalidate(3, shader = $$new_props.shader);
    if ("state" in $$new_props) $$invalidate(4, state = $$new_props.state);
    if ("drawMode" in $$new_props) $$invalidate(5, drawMode = $$new_props.drawMode);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(40, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    createApplyProps,
    geometry,
    shader,
    state,
    drawMode,
    instance: instance2,
    applyProp: applyProp2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("geometry" in $$props) $$invalidate(2, geometry = $$new_props.geometry);
    if ("shader" in $$props) $$invalidate(3, shader = $$new_props.shader);
    if ("state" in $$props) $$invalidate(4, state = $$new_props.state);
    if ("drawMode" in $$props) $$invalidate(5, drawMode = $$new_props.drawMode);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*geometry*/
    4) {
      $: applyProp2("geometry", geometry);
    }
    if ($$self.$$.dirty[0] & /*shader*/
    8) {
      $: applyProp2("shader", shader);
    }
    if ($$self.$$.dirty[0] & /*state*/
    16) {
      $: applyProp2("state", state);
    }
    if ($$self.$$.dirty[0] & /*drawMode*/
    32) {
      $: applyProp2("drawMode", drawMode);
    }
    if ($$self.$$.dirty[0] & /*drawMode*/
    32) {
      $: applyProp2("drawMode", drawMode);
    }
  };
  return [
    instance2,
    $$restProps,
    geometry,
    shader,
    state,
    drawMode,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var Mesh2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_19,
      create_fragment10,
      safe_not_equal,
      {
        geometry: 2,
        shader: 3,
        state: 4,
        drawMode: 5,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mesh",
      options,
      id: create_fragment10.name
    });
  }
  get geometry() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shader() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shader(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get drawMode() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set drawMode(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Mesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Mesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Mesh_default = Mesh2;

// node_modules/svelte-pixi/dist/NineSlicePlane.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[45],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[45]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[45],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(92:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[12]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[13]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[14]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[15]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[16]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[17]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[18]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[19]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[20]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[21]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[22]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[23]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[24]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[25]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[26]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[27]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[28]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[29]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[30]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[31]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[32]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[33]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[34]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[35]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[36]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[37]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[38]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[39]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[40]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[41]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[42]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[43]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[44]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      16384) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_110($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "texture",
    "leftWidth",
    "rightWidth",
    "topHeight",
    "bottomHeight",
    "geometry",
    "shader",
    "state",
    "drawMode",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NineSlicePlane", slots, ["default"]);
  let { texture } = $$props;
  let { leftWidth } = $$props;
  let { rightWidth } = $$props;
  let { topHeight } = $$props;
  let { bottomHeight } = $$props;
  let { geometry = void 0 } = $$props;
  let { shader = void 0 } = $$props;
  let { state = void 0 } = $$props;
  let { drawMode = void 0 } = $$props;
  let { instance: instance2 = new NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) } = $$props;
  const { invalidate } = getRenderer();
  const { applyProps: applyProps2, applyProp: applyProp2 } = createApplyProps(instance2);
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (texture === void 0 && !("texture" in $$props || $$self.$$.bound[$$self.$$.props["texture"]])) {
      console.warn("<NineSlicePlane> was created without expected prop 'texture'");
    }
    if (leftWidth === void 0 && !("leftWidth" in $$props || $$self.$$.bound[$$self.$$.props["leftWidth"]])) {
      console.warn("<NineSlicePlane> was created without expected prop 'leftWidth'");
    }
    if (rightWidth === void 0 && !("rightWidth" in $$props || $$self.$$.bound[$$self.$$.props["rightWidth"]])) {
      console.warn("<NineSlicePlane> was created without expected prop 'rightWidth'");
    }
    if (topHeight === void 0 && !("topHeight" in $$props || $$self.$$.bound[$$self.$$.props["topHeight"]])) {
      console.warn("<NineSlicePlane> was created without expected prop 'topHeight'");
    }
    if (bottomHeight === void 0 && !("bottomHeight" in $$props || $$self.$$.bound[$$self.$$.props["bottomHeight"]])) {
      console.warn("<NineSlicePlane> was created without expected prop 'bottomHeight'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("texture" in $$new_props) $$invalidate(2, texture = $$new_props.texture);
    if ("leftWidth" in $$new_props) $$invalidate(3, leftWidth = $$new_props.leftWidth);
    if ("rightWidth" in $$new_props) $$invalidate(4, rightWidth = $$new_props.rightWidth);
    if ("topHeight" in $$new_props) $$invalidate(5, topHeight = $$new_props.topHeight);
    if ("bottomHeight" in $$new_props) $$invalidate(6, bottomHeight = $$new_props.bottomHeight);
    if ("geometry" in $$new_props) $$invalidate(7, geometry = $$new_props.geometry);
    if ("shader" in $$new_props) $$invalidate(8, shader = $$new_props.shader);
    if ("state" in $$new_props) $$invalidate(9, state = $$new_props.state);
    if ("drawMode" in $$new_props) $$invalidate(10, drawMode = $$new_props.drawMode);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(45, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    createApplyProps,
    texture,
    leftWidth,
    rightWidth,
    topHeight,
    bottomHeight,
    geometry,
    shader,
    state,
    drawMode,
    instance: instance2,
    invalidate,
    applyProps: applyProps2,
    applyProp: applyProp2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("texture" in $$props) $$invalidate(2, texture = $$new_props.texture);
    if ("leftWidth" in $$props) $$invalidate(3, leftWidth = $$new_props.leftWidth);
    if ("rightWidth" in $$props) $$invalidate(4, rightWidth = $$new_props.rightWidth);
    if ("topHeight" in $$props) $$invalidate(5, topHeight = $$new_props.topHeight);
    if ("bottomHeight" in $$props) $$invalidate(6, bottomHeight = $$new_props.bottomHeight);
    if ("geometry" in $$props) $$invalidate(7, geometry = $$new_props.geometry);
    if ("shader" in $$props) $$invalidate(8, shader = $$new_props.shader);
    if ("state" in $$props) $$invalidate(9, state = $$new_props.state);
    if ("drawMode" in $$props) $$invalidate(10, drawMode = $$new_props.drawMode);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*geometry*/
    128) {
      $: applyProp2("geometry", geometry);
    }
    if ($$self.$$.dirty[0] & /*shader*/
    256) {
      $: applyProp2("shader", shader);
    }
    if ($$self.$$.dirty[0] & /*state*/
    512) {
      $: applyProp2("state", state);
    }
    if ($$self.$$.dirty[0] & /*drawMode*/
    1024) {
      $: applyProp2("drawMode", drawMode);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    4) {
      $: applyProp2("texture", texture);
    }
    if ($$self.$$.dirty[0] & /*leftWidth, rightWidth, topHeight, bottomHeight*/
    120) {
      $: applyProps2({
        leftWidth,
        rightWidth,
        topHeight,
        bottomHeight
      });
    }
    if ($$self.$$.dirty[0] & /*texture*/
    4) {
      $: texture.on("update", () => invalidate());
    }
  };
  return [
    instance2,
    $$restProps,
    texture,
    leftWidth,
    rightWidth,
    topHeight,
    bottomHeight,
    geometry,
    shader,
    state,
    drawMode,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var NineSlicePlane2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_110,
      create_fragment11,
      safe_not_equal,
      {
        texture: 2,
        leftWidth: 3,
        rightWidth: 4,
        topHeight: 5,
        bottomHeight: 6,
        geometry: 7,
        shader: 8,
        state: 9,
        drawMode: 10,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NineSlicePlane",
      options,
      id: create_fragment11.name
    });
  }
  get texture() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set texture(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get leftWidth() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set leftWidth(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightWidth() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightWidth(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topHeight() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topHeight(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottomHeight() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottomHeight(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shader() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shader(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get drawMode() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set drawMode(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<NineSlicePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<NineSlicePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NineSlicePlane_default = NineSlicePlane2;

// node_modules/svelte-pixi/dist/ParticleContainer.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[40],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[40]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[40],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(39:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[7]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[8]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[9]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[10]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[11]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[12]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[13]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[14]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[15]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[16]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[17]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[18]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[19]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[20]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[21]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[22]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[23]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[24]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[25]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[26]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[27]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[28]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[29]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[30]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[31]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[32]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[33]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[34]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[35]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[36]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[37]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[38]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[39]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      512) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_111($$self, $$props, $$invalidate) {
  const omit_props_names = ["maxSize", "properties", "batchSize", "autoResize", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ParticleContainer", slots, ["default"]);
  let { maxSize = 1500 } = $$props;
  let { properties = void 0 } = $$props;
  let { batchSize = 16384 } = $$props;
  let { autoResize = false } = $$props;
  let { instance: instance2 = new ParticleContainer(maxSize, properties, batchSize, autoResize) } = $$props;
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("maxSize" in $$new_props) $$invalidate(2, maxSize = $$new_props.maxSize);
    if ("properties" in $$new_props) $$invalidate(3, properties = $$new_props.properties);
    if ("batchSize" in $$new_props) $$invalidate(4, batchSize = $$new_props.batchSize);
    if ("autoResize" in $$new_props) $$invalidate(5, autoResize = $$new_props.autoResize);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(40, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    maxSize,
    properties,
    batchSize,
    autoResize,
    instance: instance2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("maxSize" in $$props) $$invalidate(2, maxSize = $$new_props.maxSize);
    if ("properties" in $$props) $$invalidate(3, properties = $$new_props.properties);
    if ("batchSize" in $$props) $$invalidate(4, batchSize = $$new_props.batchSize);
    if ("autoResize" in $$props) $$invalidate(5, autoResize = $$new_props.autoResize);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    instance2,
    $$restProps,
    maxSize,
    properties,
    batchSize,
    autoResize,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var ParticleContainer2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_111,
      create_fragment12,
      safe_not_equal,
      {
        maxSize: 2,
        properties: 3,
        batchSize: 4,
        autoResize: 5,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ParticleContainer",
      options,
      id: create_fragment12.name
    });
  }
  get maxSize() {
    throw new Error("<ParticleContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxSize(value) {
    throw new Error("<ParticleContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get properties() {
    throw new Error("<ParticleContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set properties(value) {
    throw new Error("<ParticleContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get batchSize() {
    throw new Error("<ParticleContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set batchSize(value) {
    throw new Error("<ParticleContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoResize() {
    throw new Error("<ParticleContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoResize(value) {
    throw new Error("<ParticleContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<ParticleContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<ParticleContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ParticleContainer_default = ParticleContainer2;

// node_modules/svelte-pixi/dist/SimplePlane.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[42],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[42],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[42]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[42],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(71:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[9]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[11]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[12]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[13]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[14]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[15]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[16]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[17]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[18]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[19]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[20]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[21]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[22]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[23]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[24]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[25]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[26]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[27]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[28]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[29]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[30]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[31]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[32]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[33]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[34]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[35]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[36]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[37]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[38]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[39]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[40]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[41]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2048) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_112($$self, $$props, $$invalidate) {
  const omit_props_names = ["texture", "vertices", "geometry", "shader", "state", "drawMode", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SimplePlane", slots, ["default"]);
  let { texture } = $$props;
  let { vertices } = $$props;
  let { geometry = void 0 } = $$props;
  let { shader = void 0 } = $$props;
  let { state = void 0 } = $$props;
  let { drawMode = void 0 } = $$props;
  let { instance: instance2 = new SimplePlane(texture, parsePoint(vertices).x, parsePoint(vertices).y) } = $$props;
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (texture === void 0 && !("texture" in $$props || $$self.$$.bound[$$self.$$.props["texture"]])) {
      console.warn("<SimplePlane> was created without expected prop 'texture'");
    }
    if (vertices === void 0 && !("vertices" in $$props || $$self.$$.bound[$$self.$$.props["vertices"]])) {
      console.warn("<SimplePlane> was created without expected prop 'vertices'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("texture" in $$new_props) $$invalidate(2, texture = $$new_props.texture);
    if ("vertices" in $$new_props) $$invalidate(3, vertices = $$new_props.vertices);
    if ("geometry" in $$new_props) $$invalidate(4, geometry = $$new_props.geometry);
    if ("shader" in $$new_props) $$invalidate(5, shader = $$new_props.shader);
    if ("state" in $$new_props) $$invalidate(6, state = $$new_props.state);
    if ("drawMode" in $$new_props) $$invalidate(7, drawMode = $$new_props.drawMode);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(42, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    parsePoint,
    createApplyProps,
    texture,
    vertices,
    geometry,
    shader,
    state,
    drawMode,
    instance: instance2,
    applyProp: applyProp2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("texture" in $$props) $$invalidate(2, texture = $$new_props.texture);
    if ("vertices" in $$props) $$invalidate(3, vertices = $$new_props.vertices);
    if ("geometry" in $$props) $$invalidate(4, geometry = $$new_props.geometry);
    if ("shader" in $$props) $$invalidate(5, shader = $$new_props.shader);
    if ("state" in $$props) $$invalidate(6, state = $$new_props.state);
    if ("drawMode" in $$props) $$invalidate(7, drawMode = $$new_props.drawMode);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*geometry*/
    16) {
      $: applyProp2("geometry", geometry);
    }
    if ($$self.$$.dirty[0] & /*shader*/
    32) {
      $: applyProp2("shader", shader);
    }
    if ($$self.$$.dirty[0] & /*state*/
    64) {
      $: applyProp2("state", state);
    }
    if ($$self.$$.dirty[0] & /*drawMode*/
    128) {
      $: applyProp2("drawMode", drawMode);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    4) {
      $: applyProp2("texture", texture);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    4) {
      $: texture.on("update", () => invalidate());
    }
  };
  return [
    instance2,
    $$restProps,
    texture,
    vertices,
    geometry,
    shader,
    state,
    drawMode,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var SimplePlane2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_112,
      create_fragment13,
      safe_not_equal,
      {
        texture: 2,
        vertices: 3,
        geometry: 4,
        shader: 5,
        state: 6,
        drawMode: 7,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SimplePlane",
      options,
      id: create_fragment13.name
    });
  }
  get texture() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set texture(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertices() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertices(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shader() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shader(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get drawMode() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set drawMode(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<SimplePlane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<SimplePlane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SimplePlane_default = SimplePlane2;

// node_modules/svelte-pixi/dist/SimpleRope.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(90:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[10]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[11]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[12]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[13]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[14]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[15]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[16]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[17]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[18]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[19]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[20]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[21]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[22]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[23]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[24]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[25]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[26]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[27]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[28]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[29]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[30]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[31]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[32]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[33]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[34]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[35]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[36]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[37]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[38]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[39]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[40]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[41]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[42]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      4096) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_113($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "texture",
    "points",
    "textureScale",
    "geometry",
    "shader",
    "state",
    "drawMode",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SimpleRope", slots, ["default"]);
  let { texture } = $$props;
  let { points } = $$props;
  let { textureScale = 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { shader = void 0 } = $$props;
  let { state = void 0 } = $$props;
  let { drawMode = void 0 } = $$props;
  let { instance: instance2 = new SimpleRope(texture, parsePoints(points), textureScale) } = $$props;
  function parsePoints(points2) {
    return points2.map(parsePoint);
  }
  const { applyProp: applyProp2 } = createApplyProps(instance2, {
    // PIXI.SimpleRope only uses points to create the geometry on construction,
    // so we need to recreate it whenever points change
    points: (value, instance3) => {
      instance3.geometry = new RopeGeometry(texture.height, parsePoints(value), textureScale);
    }
  });
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (texture === void 0 && !("texture" in $$props || $$self.$$.bound[$$self.$$.props["texture"]])) {
      console.warn("<SimpleRope> was created without expected prop 'texture'");
    }
    if (points === void 0 && !("points" in $$props || $$self.$$.bound[$$self.$$.props["points"]])) {
      console.warn("<SimpleRope> was created without expected prop 'points'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("texture" in $$new_props) $$invalidate(2, texture = $$new_props.texture);
    if ("points" in $$new_props) $$invalidate(3, points = $$new_props.points);
    if ("textureScale" in $$new_props) $$invalidate(4, textureScale = $$new_props.textureScale);
    if ("geometry" in $$new_props) $$invalidate(5, geometry = $$new_props.geometry);
    if ("shader" in $$new_props) $$invalidate(6, shader = $$new_props.shader);
    if ("state" in $$new_props) $$invalidate(7, state = $$new_props.state);
    if ("drawMode" in $$new_props) $$invalidate(8, drawMode = $$new_props.drawMode);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    parsePoint,
    createApplyProps,
    texture,
    points,
    textureScale,
    geometry,
    shader,
    state,
    drawMode,
    instance: instance2,
    parsePoints,
    applyProp: applyProp2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("texture" in $$props) $$invalidate(2, texture = $$new_props.texture);
    if ("points" in $$props) $$invalidate(3, points = $$new_props.points);
    if ("textureScale" in $$props) $$invalidate(4, textureScale = $$new_props.textureScale);
    if ("geometry" in $$props) $$invalidate(5, geometry = $$new_props.geometry);
    if ("shader" in $$props) $$invalidate(6, shader = $$new_props.shader);
    if ("state" in $$props) $$invalidate(7, state = $$new_props.state);
    if ("drawMode" in $$props) $$invalidate(8, drawMode = $$new_props.drawMode);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*geometry*/
    32) {
      $: applyProp2("geometry", geometry);
    }
    if ($$self.$$.dirty[0] & /*shader*/
    64) {
      $: applyProp2("shader", shader);
    }
    if ($$self.$$.dirty[0] & /*state*/
    128) {
      $: applyProp2("state", state);
    }
    if ($$self.$$.dirty[0] & /*drawMode*/
    256) {
      $: applyProp2("drawMode", drawMode);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    4) {
      $: applyProp2("texture", texture);
    }
    if ($$self.$$.dirty[0] & /*points*/
    8) {
      $: applyProp2("points", points);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    4) {
      $: texture.on("update", () => invalidate());
    }
  };
  return [
    instance2,
    $$restProps,
    texture,
    points,
    textureScale,
    geometry,
    shader,
    state,
    drawMode,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var SimpleRope2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_113,
      create_fragment14,
      safe_not_equal,
      {
        texture: 2,
        points: 3,
        textureScale: 4,
        geometry: 5,
        shader: 6,
        state: 7,
        drawMode: 8,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SimpleRope",
      options,
      id: create_fragment14.name
    });
  }
  get texture() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set texture(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get points() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set points(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textureScale() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textureScale(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shader() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shader(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get drawMode() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set drawMode(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<SimpleRope>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<SimpleRope>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SimpleRope_default = SimpleRope2;

// node_modules/svelte-pixi/dist/Sprite.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[41],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[41],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[41]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[41],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(59:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[8]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[10]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[11]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[12]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[13]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[14]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[15]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[16]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[17]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[18]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[19]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[20]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[21]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[22]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[23]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[24]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[25]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[26]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[27]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[28]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[29]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[30]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[31]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[32]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[33]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[34]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[35]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[36]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[37]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[38]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[39]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[40]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      1024) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_114($$self, $$props, $$invalidate) {
  const omit_props_names = ["anchor", "blendMode", "pluginName", "roundPixels", "texture", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sprite", slots, ["default"]);
  let { anchor = void 0 } = $$props;
  let { blendMode = BLEND_MODES.NORMAL } = $$props;
  let { pluginName = void 0 } = $$props;
  let { roundPixels = void 0 } = $$props;
  let { texture } = $$props;
  let { instance: instance2 = new Sprite(texture) } = $$props;
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (texture === void 0 && !("texture" in $$props || $$self.$$.bound[$$self.$$.props["texture"]])) {
      console.warn("<Sprite> was created without expected prop 'texture'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("anchor" in $$new_props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("blendMode" in $$new_props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$new_props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$new_props) $$invalidate(5, roundPixels = $$new_props.roundPixels);
    if ("texture" in $$new_props) $$invalidate(6, texture = $$new_props.texture);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(41, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    Container: Container_default,
    getRenderer,
    createApplyProps,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    texture,
    instance: instance2,
    applyProp: applyProp2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("anchor" in $$props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("blendMode" in $$props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$props) $$invalidate(5, roundPixels = $$new_props.roundPixels);
    if ("texture" in $$props) $$invalidate(6, texture = $$new_props.texture);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*anchor*/
    4) {
      $: applyProp2("anchor", anchor);
    }
    if ($$self.$$.dirty[0] & /*blendMode*/
    8) {
      $: applyProp2("blendMode", blendMode);
    }
    if ($$self.$$.dirty[0] & /*pluginName*/
    16) {
      $: applyProp2("pluginName", pluginName);
    }
    if ($$self.$$.dirty[0] & /*roundPixels*/
    32) {
      $: applyProp2("roundPixels", roundPixels);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    64) {
      $: applyProp2("texture", texture);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    64) {
      $: texture.on("update", () => invalidate());
    }
  };
  return [
    instance2,
    $$restProps,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    texture,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var Sprite2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_114,
      create_fragment15,
      safe_not_equal,
      {
        anchor: 2,
        blendMode: 3,
        pluginName: 4,
        roundPixels: 5,
        texture: 6,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sprite",
      options,
      id: create_fragment15.name
    });
  }
  get anchor() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blendMode() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blendMode(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pluginName() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pluginName(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundPixels() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundPixels(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get texture() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set texture(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Sprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Sprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sprite_default = Sprite2;

// node_modules/svelte-pixi/dist/Text.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[42],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[42],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[42]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[42],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(65:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[9]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[11]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[12]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[13]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[14]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[15]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[16]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[17]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[18]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[19]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[20]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[21]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[22]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[23]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[24]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[25]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[26]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[27]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[28]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[29]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[30]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[31]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[32]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[33]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[34]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[35]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[36]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[37]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[38]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[39]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[40]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[41]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      2048) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_115($$self, $$props, $$invalidate) {
  const omit_props_names = ["text", "style", "anchor", "blendMode", "pluginName", "roundPixels", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { text } = $$props;
  let { style = void 0 } = $$props;
  let { anchor = void 0 } = $$props;
  let { blendMode = BLEND_MODES.NORMAL } = $$props;
  let { pluginName = void 0 } = $$props;
  let { roundPixels = void 0 } = $$props;
  let { instance: instance2 = new Text(text, style) } = $$props;
  const { invalidate } = getRenderer();
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (text === void 0 && !("text" in $$props || $$self.$$.bound[$$self.$$.props["text"]])) {
      console.warn("<Text> was created without expected prop 'text'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
    if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    if ("anchor" in $$new_props) $$invalidate(4, anchor = $$new_props.anchor);
    if ("blendMode" in $$new_props) $$invalidate(5, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$new_props) $$invalidate(6, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$new_props) $$invalidate(7, roundPixels = $$new_props.roundPixels);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(42, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    createApplyProps,
    Container: Container_default,
    afterUpdate,
    getRenderer,
    text,
    style,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    instance: instance2,
    invalidate,
    applyProp: applyProp2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
    if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    if ("anchor" in $$props) $$invalidate(4, anchor = $$new_props.anchor);
    if ("blendMode" in $$props) $$invalidate(5, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$props) $$invalidate(6, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$props) $$invalidate(7, roundPixels = $$new_props.roundPixels);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*text*/
    4) {
      $: applyProp2("text", text);
    }
    if ($$self.$$.dirty[0] & /*style*/
    8) {
      $: applyProp2("style", style);
    }
    if ($$self.$$.dirty[0] & /*anchor*/
    16) {
      $: applyProp2("anchor", anchor);
    }
    if ($$self.$$.dirty[0] & /*blendMode*/
    32) {
      $: applyProp2("blendMode", blendMode);
    }
    if ($$self.$$.dirty[0] & /*pluginName*/
    64) {
      $: applyProp2("pluginName", pluginName);
    }
    if ($$self.$$.dirty[0] & /*roundPixels*/
    128) {
      $: applyProp2("roundPixels", roundPixels);
    }
  };
  return [
    instance2,
    $$restProps,
    text,
    style,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var Text2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_115,
      create_fragment16,
      safe_not_equal,
      {
        text: 2,
        style: 3,
        anchor: 4,
        blendMode: 5,
        pluginName: 6,
        roundPixels: 7,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment16.name
    });
  }
  get text() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blendMode() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blendMode(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pluginName() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pluginName(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundPixels() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundPixels(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text2;

// node_modules/svelte-pixi/dist/TilingSprite.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[48],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[48]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[48],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(110:0) <Container   {...$$restProps}   {instance}   on:create   on:click   on:globalmousemove   on:globalpointermove   on:globaltouchmove   on:mousedown   on:mousemove   on:mouseout   on:mouseover   on:mouseup   on:mouseupoutside   on:mouseupoutside   on:pointercancel   on:pointerdown   on:pointermove   on:pointerout   on:pointerover   on:pointertap   on:pointerup   on:pointerupoutside   on:removedFrom   on:rightclick   on:rightdown   on:rightup   on:rightupoutside   on:tap   on:touchcancel   on:touchend   on:touchendoutside   on:touchmove   on:touchstart   on:added   on:removed >",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let container;
  let current;
  const container_spread_levels = [
    /*$$restProps*/
    ctx[1],
    { instance: (
      /*instance*/
      ctx[0]
    ) }
  ];
  let container_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < container_spread_levels.length; i += 1) {
    container_props = assign(container_props, container_spread_levels[i]);
  }
  container = new Container_default({ props: container_props, $$inline: true });
  container.$on(
    "create",
    /*create_handler*/
    ctx[15]
  );
  container.$on(
    "click",
    /*click_handler*/
    ctx[16]
  );
  container.$on(
    "globalmousemove",
    /*globalmousemove_handler*/
    ctx[17]
  );
  container.$on(
    "globalpointermove",
    /*globalpointermove_handler*/
    ctx[18]
  );
  container.$on(
    "globaltouchmove",
    /*globaltouchmove_handler*/
    ctx[19]
  );
  container.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx[20]
  );
  container.$on(
    "mousemove",
    /*mousemove_handler*/
    ctx[21]
  );
  container.$on(
    "mouseout",
    /*mouseout_handler*/
    ctx[22]
  );
  container.$on(
    "mouseover",
    /*mouseover_handler*/
    ctx[23]
  );
  container.$on(
    "mouseup",
    /*mouseup_handler*/
    ctx[24]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler*/
    ctx[25]
  );
  container.$on(
    "mouseupoutside",
    /*mouseupoutside_handler_1*/
    ctx[26]
  );
  container.$on(
    "pointercancel",
    /*pointercancel_handler*/
    ctx[27]
  );
  container.$on(
    "pointerdown",
    /*pointerdown_handler*/
    ctx[28]
  );
  container.$on(
    "pointermove",
    /*pointermove_handler*/
    ctx[29]
  );
  container.$on(
    "pointerout",
    /*pointerout_handler*/
    ctx[30]
  );
  container.$on(
    "pointerover",
    /*pointerover_handler*/
    ctx[31]
  );
  container.$on(
    "pointertap",
    /*pointertap_handler*/
    ctx[32]
  );
  container.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[33]
  );
  container.$on(
    "pointerupoutside",
    /*pointerupoutside_handler*/
    ctx[34]
  );
  container.$on(
    "removedFrom",
    /*removedFrom_handler*/
    ctx[35]
  );
  container.$on(
    "rightclick",
    /*rightclick_handler*/
    ctx[36]
  );
  container.$on(
    "rightdown",
    /*rightdown_handler*/
    ctx[37]
  );
  container.$on(
    "rightup",
    /*rightup_handler*/
    ctx[38]
  );
  container.$on(
    "rightupoutside",
    /*rightupoutside_handler*/
    ctx[39]
  );
  container.$on(
    "tap",
    /*tap_handler*/
    ctx[40]
  );
  container.$on(
    "touchcancel",
    /*touchcancel_handler*/
    ctx[41]
  );
  container.$on(
    "touchend",
    /*touchend_handler*/
    ctx[42]
  );
  container.$on(
    "touchendoutside",
    /*touchendoutside_handler*/
    ctx[43]
  );
  container.$on(
    "touchmove",
    /*touchmove_handler*/
    ctx[44]
  );
  container.$on(
    "touchstart",
    /*touchstart_handler*/
    ctx[45]
  );
  container.$on(
    "added",
    /*added_handler*/
    ctx[46]
  );
  container.$on(
    "removed",
    /*removed_handler*/
    ctx[47]
  );
  const block = {
    c: function create() {
      create_component(container.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(container, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_changes = dirty[0] & /*$$restProps, instance*/
      3 ? get_spread_update(container_spread_levels, [
        dirty[0] & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        ),
        dirty[0] & /*instance*/
        1 && { instance: (
          /*instance*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty[1] & /*$$scope*/
      131072) {
        container_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container.$set(container_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(container.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_116($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "anchor",
    "blendMode",
    "pluginName",
    "roundPixels",
    "clampMargin",
    "height",
    "texture",
    "tilePosition",
    "tileTransform",
    "uvMatrix",
    "uvRespectAnchor",
    "width",
    "instance"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TilingSprite", slots, ["default"]);
  let { anchor = void 0 } = $$props;
  let { blendMode = BLEND_MODES.NORMAL } = $$props;
  let { pluginName = void 0 } = $$props;
  let { roundPixels = void 0 } = $$props;
  let { clampMargin = 0.5 } = $$props;
  let { height } = $$props;
  let { texture } = $$props;
  let { tilePosition = void 0 } = $$props;
  let { tileTransform = void 0 } = $$props;
  let { uvMatrix = void 0 } = $$props;
  let { uvRespectAnchor = void 0 } = $$props;
  let { width } = $$props;
  let { instance: instance2 = new TilingSprite(texture, width, height) } = $$props;
  const { applyProp: applyProp2 } = createApplyProps(instance2);
  const { invalidate } = getRenderer();
  afterUpdate(() => {
    invalidate();
  });
  $$self.$$.on_mount.push(function() {
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<TilingSprite> was created without expected prop 'height'");
    }
    if (texture === void 0 && !("texture" in $$props || $$self.$$.bound[$$self.$$.props["texture"]])) {
      console.warn("<TilingSprite> was created without expected prop 'texture'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<TilingSprite> was created without expected prop 'width'");
    }
  });
  function create_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalmousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalpointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globaltouchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousemove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseupoutside_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointercancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointermove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointertap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function pointerupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removedFrom_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightclick_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightdown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function rightupoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function tap_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchcancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchendoutside_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchmove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function added_handler(event) {
    bubble.call(this, $$self, event);
  }
  function removed_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("anchor" in $$new_props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("blendMode" in $$new_props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$new_props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$new_props) $$invalidate(5, roundPixels = $$new_props.roundPixels);
    if ("clampMargin" in $$new_props) $$invalidate(6, clampMargin = $$new_props.clampMargin);
    if ("height" in $$new_props) $$invalidate(7, height = $$new_props.height);
    if ("texture" in $$new_props) $$invalidate(8, texture = $$new_props.texture);
    if ("tilePosition" in $$new_props) $$invalidate(9, tilePosition = $$new_props.tilePosition);
    if ("tileTransform" in $$new_props) $$invalidate(10, tileTransform = $$new_props.tileTransform);
    if ("uvMatrix" in $$new_props) $$invalidate(11, uvMatrix = $$new_props.uvMatrix);
    if ("uvRespectAnchor" in $$new_props) $$invalidate(12, uvRespectAnchor = $$new_props.uvRespectAnchor);
    if ("width" in $$new_props) $$invalidate(13, width = $$new_props.width);
    if ("instance" in $$new_props) $$invalidate(0, instance2 = $$new_props.instance);
    if ("$$scope" in $$new_props) $$invalidate(48, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    PIXI: lib_exports,
    afterUpdate,
    getRenderer,
    Container: Container_default,
    createApplyProps,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    clampMargin,
    height,
    texture,
    tilePosition,
    tileTransform,
    uvMatrix,
    uvRespectAnchor,
    width,
    instance: instance2,
    applyProp: applyProp2,
    invalidate
  });
  $$self.$inject_state = ($$new_props) => {
    if ("anchor" in $$props) $$invalidate(2, anchor = $$new_props.anchor);
    if ("blendMode" in $$props) $$invalidate(3, blendMode = $$new_props.blendMode);
    if ("pluginName" in $$props) $$invalidate(4, pluginName = $$new_props.pluginName);
    if ("roundPixels" in $$props) $$invalidate(5, roundPixels = $$new_props.roundPixels);
    if ("clampMargin" in $$props) $$invalidate(6, clampMargin = $$new_props.clampMargin);
    if ("height" in $$props) $$invalidate(7, height = $$new_props.height);
    if ("texture" in $$props) $$invalidate(8, texture = $$new_props.texture);
    if ("tilePosition" in $$props) $$invalidate(9, tilePosition = $$new_props.tilePosition);
    if ("tileTransform" in $$props) $$invalidate(10, tileTransform = $$new_props.tileTransform);
    if ("uvMatrix" in $$props) $$invalidate(11, uvMatrix = $$new_props.uvMatrix);
    if ("uvRespectAnchor" in $$props) $$invalidate(12, uvRespectAnchor = $$new_props.uvRespectAnchor);
    if ("width" in $$props) $$invalidate(13, width = $$new_props.width);
    if ("instance" in $$props) $$invalidate(0, instance2 = $$new_props.instance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*anchor*/
    4) {
      $: applyProp2("anchor", anchor);
    }
    if ($$self.$$.dirty[0] & /*blendMode*/
    8) {
      $: applyProp2("blendMode", blendMode);
    }
    if ($$self.$$.dirty[0] & /*pluginName*/
    16) {
      $: applyProp2("pluginName", pluginName);
    }
    if ($$self.$$.dirty[0] & /*roundPixels*/
    32) {
      $: applyProp2("roundPixels", roundPixels);
    }
    if ($$self.$$.dirty[0] & /*clampMargin*/
    64) {
      $: applyProp2("clampMargin", clampMargin);
    }
    if ($$self.$$.dirty[0] & /*height*/
    128) {
      $: applyProp2("height", height);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    256) {
      $: applyProp2("texture", texture);
    }
    if ($$self.$$.dirty[0] & /*tilePosition*/
    512) {
      $: applyProp2("tilePosition", tilePosition);
    }
    if ($$self.$$.dirty[0] & /*tileTransform*/
    1024) {
      $: applyProp2("tileTransform", tileTransform);
    }
    if ($$self.$$.dirty[0] & /*uvMatrix*/
    2048) {
      $: applyProp2("uvMatrix", uvMatrix);
    }
    if ($$self.$$.dirty[0] & /*uvRespectAnchor*/
    4096) {
      $: applyProp2("uvRespectAnchor", uvRespectAnchor);
    }
    if ($$self.$$.dirty[0] & /*width*/
    8192) {
      $: applyProp2("width", width);
    }
    if ($$self.$$.dirty[0] & /*texture*/
    256) {
      $: texture.on("update", () => invalidate());
    }
  };
  return [
    instance2,
    $$restProps,
    anchor,
    blendMode,
    pluginName,
    roundPixels,
    clampMargin,
    height,
    texture,
    tilePosition,
    tileTransform,
    uvMatrix,
    uvRespectAnchor,
    width,
    slots,
    create_handler,
    click_handler,
    globalmousemove_handler,
    globalpointermove_handler,
    globaltouchmove_handler,
    mousedown_handler,
    mousemove_handler,
    mouseout_handler,
    mouseover_handler,
    mouseup_handler,
    mouseupoutside_handler,
    mouseupoutside_handler_1,
    pointercancel_handler,
    pointerdown_handler,
    pointermove_handler,
    pointerout_handler,
    pointerover_handler,
    pointertap_handler,
    pointerup_handler,
    pointerupoutside_handler,
    removedFrom_handler,
    rightclick_handler,
    rightdown_handler,
    rightup_handler,
    rightupoutside_handler,
    tap_handler,
    touchcancel_handler,
    touchend_handler,
    touchendoutside_handler,
    touchmove_handler,
    touchstart_handler,
    added_handler,
    removed_handler,
    $$scope
  ];
}
var TilingSprite2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_116,
      create_fragment17,
      safe_not_equal,
      {
        anchor: 2,
        blendMode: 3,
        pluginName: 4,
        roundPixels: 5,
        clampMargin: 6,
        height: 7,
        texture: 8,
        tilePosition: 9,
        tileTransform: 10,
        uvMatrix: 11,
        uvRespectAnchor: 12,
        width: 13,
        instance: 0
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TilingSprite",
      options,
      id: create_fragment17.name
    });
  }
  get anchor() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blendMode() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blendMode(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pluginName() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pluginName(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get roundPixels() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set roundPixels(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clampMargin() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clampMargin(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get texture() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set texture(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tilePosition() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tilePosition(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tileTransform() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tileTransform(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get uvMatrix() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set uvMatrix(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get uvRespectAnchor() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set uvRespectAnchor(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<TilingSprite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<TilingSprite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TilingSprite_default = TilingSprite2;
export {
  AnimatedSprite_default as AnimatedSprite,
  Application_default as Application,
  AssetsLoader_default as AssetsLoader,
  BitmapText_default as BitmapText,
  Container_default as Container,
  Graphics_default as Graphics,
  HTMLText_default as HTMLText,
  Mesh_default as Mesh,
  NineSlicePlane_default as NineSlicePlane,
  ParticleContainer_default as ParticleContainer,
  Renderer_default as Renderer,
  SimplePlane_default as SimplePlane,
  SimpleRope_default as SimpleRope,
  Sprite_default as Sprite,
  Text_default as Text,
  Ticker_default as Ticker,
  TilingSprite_default as TilingSprite,
  applyProp,
  applyProps,
  createApplyProps,
  getApp,
  getContainer,
  getRenderer,
  getStage,
  getTicker,
  onTick,
  track
};
//# sourceMappingURL=svelte-pixi.js.map
